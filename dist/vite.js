var $J=44,YJ=59,o="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",s=new Uint8Array(64),FJ=new Uint8Array(128);for(let J=0;J<o.length;J++){let Q=o.charCodeAt(J);s[J]=Q,FJ[Q]=J}function b(J,Q,X){let Z=Q-X;Z=Z<0?-Z<<1|1:Z<<1;do{let $=Z&31;if(Z>>>=5,Z>0)$|=32;J.write(s[$])}while(Z>0);return Q}var i=16384,a=typeof TextDecoder!=="undefined"?new TextDecoder:typeof Buffer!=="undefined"?{decode(J){return Buffer.from(J.buffer,J.byteOffset,J.byteLength).toString()}}:{decode(J){let Q="";for(let X=0;X<J.length;X++)Q+=String.fromCharCode(J[X]);return Q}},zJ=class{constructor(){this.pos=0,this.out="",this.buffer=new Uint8Array(i)}write(J){let{buffer:Q}=this;if(Q[this.pos++]=J,this.pos===i)this.out+=a.decode(Q),this.pos=0}flush(){let{buffer:J,out:Q,pos:X}=this;return X>0?Q+a.decode(J.subarray(0,X)):Q}};function r(J){let Q=new zJ,X=0,Z=0,$=0,Y=0;for(let z=0;z<J.length;z++){let F=J[z];if(z>0)Q.write(YJ);if(F.length===0)continue;let W=0;for(let q=0;q<F.length;q++){let A=F[q];if(q>0)Q.write($J);if(W=b(Q,A[0],W),A.length===1)continue;if(X=b(Q,A[1],X),Z=b(Q,A[2],Z),$=b(Q,A[3],$),A.length===4)continue;Y=b(Q,A[4],Y)}}return Q.flush()}class x{constructor(J){this.bits=J instanceof x?J.bits.slice():[]}add(J){this.bits[J>>5]|=1<<(J&31)}has(J){return!!(this.bits[J>>5]&1<<(J&31))}}class w{constructor(J,Q,X){this.start=J,this.end=Q,this.original=X,this.intro="",this.outro="",this.content=X,this.storeName=!1,this.edited=!1,this.previous=null,this.next=null}appendLeft(J){this.outro+=J}appendRight(J){this.intro=this.intro+J}clone(){let J=new w(this.start,this.end,this.original);return J.intro=this.intro,J.outro=this.outro,J.content=this.content,J.storeName=this.storeName,J.edited=this.edited,J}contains(J){return this.start<J&&J<this.end}eachNext(J){let Q=this;while(Q)J(Q),Q=Q.next}eachPrevious(J){let Q=this;while(Q)J(Q),Q=Q.previous}edit(J,Q,X){if(this.content=J,!X)this.intro="",this.outro="";return this.storeName=Q,this.edited=!0,this}prependLeft(J){this.outro=J+this.outro}prependRight(J){this.intro=J+this.intro}reset(){if(this.intro="",this.outro="",this.edited)this.content=this.original,this.storeName=!1,this.edited=!1}split(J){let Q=J-this.start,X=this.original.slice(0,Q),Z=this.original.slice(Q);this.original=X;let $=new w(J,this.end,Z);if($.outro=this.outro,this.outro="",this.end=J,this.edited)$.edit("",!1),this.content="";else this.content=X;if($.next=this.next,$.next)$.next.previous=$;return $.previous=this,this.next=$,$}toString(){return this.intro+this.content+this.outro}trimEnd(J){if(this.outro=this.outro.replace(J,""),this.outro.length)return!0;let Q=this.content.replace(J,"");if(Q.length){if(Q!==this.content){if(this.split(this.start+Q.length).edit("",void 0,!0),this.edited)this.edit(Q,this.storeName,!0)}return!0}else if(this.edit("",void 0,!0),this.intro=this.intro.replace(J,""),this.intro.length)return!0}trimStart(J){if(this.intro=this.intro.replace(J,""),this.intro.length)return!0;let Q=this.content.replace(J,"");if(Q.length){if(Q!==this.content){let X=this.split(this.end-Q.length);if(this.edited)X.edit(Q,this.storeName,!0);this.edit("",void 0,!0)}return!0}else if(this.edit("",void 0,!0),this.outro=this.outro.replace(J,""),this.outro.length)return!0}}function WJ(){if(typeof globalThis!=="undefined"&&typeof globalThis.btoa==="function")return(J)=>globalThis.btoa(unescape(encodeURIComponent(J)));else if(typeof Buffer==="function")return(J)=>Buffer.from(J,"utf-8").toString("base64");else return()=>{throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.")}}var HJ=WJ();class n{constructor(J){if(this.version=3,this.file=J.file,this.sources=J.sources,this.sourcesContent=J.sourcesContent,this.names=J.names,this.mappings=r(J.mappings),typeof J.x_google_ignoreList!=="undefined")this.x_google_ignoreList=J.x_google_ignoreList;if(typeof J.debugId!=="undefined")this.debugId=J.debugId}toString(){return JSON.stringify(this)}toUrl(){return"data:application/json;charset=utf-8;base64,"+HJ(this.toString())}}function qJ(J){let Q=J.split(`
`),X=Q.filter((Y)=>/^\t+/.test(Y)),Z=Q.filter((Y)=>/^ {2,}/.test(Y));if(X.length===0&&Z.length===0)return null;if(X.length>=Z.length)return"\t";let $=Z.reduce((Y,z)=>{let F=/^ +/.exec(z)[0].length;return Math.min(F,Y)},1/0);return new Array($+1).join(" ")}function AJ(J,Q){let X=J.split(/[/\\]/),Z=Q.split(/[/\\]/);X.pop();while(X[0]===Z[0])X.shift(),Z.shift();if(X.length){let $=X.length;while($--)X[$]=".."}return X.concat(Z).join("/")}var GJ=Object.prototype.toString;function UJ(J){return GJ.call(J)==="[object Object]"}function t(J){let Q=J.split(`
`),X=[];for(let Z=0,$=0;Z<Q.length;Z++)X.push($),$+=Q[Z].length+1;return function Z($){let Y=0,z=X.length;while(Y<z){let q=Y+z>>1;if($<X[q])z=q;else Y=q+1}let F=Y-1,W=$-X[F];return{line:F,column:W}}}var KJ=/\w/;class e{constructor(J){this.hires=J,this.generatedCodeLine=0,this.generatedCodeColumn=0,this.raw=[],this.rawSegments=this.raw[this.generatedCodeLine]=[],this.pending=null}addEdit(J,Q,X,Z){if(Q.length){let $=Q.length-1,Y=Q.indexOf(`
`,0),z=-1;while(Y>=0&&$>Y){let W=[this.generatedCodeColumn,J,X.line,X.column];if(Z>=0)W.push(Z);this.rawSegments.push(W),this.generatedCodeLine+=1,this.raw[this.generatedCodeLine]=this.rawSegments=[],this.generatedCodeColumn=0,z=Y,Y=Q.indexOf(`
`,Y+1)}let F=[this.generatedCodeColumn,J,X.line,X.column];if(Z>=0)F.push(Z);this.rawSegments.push(F),this.advance(Q.slice(z+1))}else if(this.pending)this.rawSegments.push(this.pending),this.advance(Q);this.pending=null}addUneditedChunk(J,Q,X,Z,$){let Y=Q.start,z=!0,F=!1;while(Y<Q.end){if(X[Y]===`
`)Z.line+=1,Z.column=0,this.generatedCodeLine+=1,this.raw[this.generatedCodeLine]=this.rawSegments=[],this.generatedCodeColumn=0,z=!0,F=!1;else{if(this.hires||z||$.has(Y)){let W=[this.generatedCodeColumn,J,Z.line,Z.column];if(this.hires==="boundary")if(KJ.test(X[Y])){if(!F)this.rawSegments.push(W),F=!0}else this.rawSegments.push(W),F=!1;else this.rawSegments.push(W)}Z.column+=1,this.generatedCodeColumn+=1,z=!1}Y+=1}this.pending=null}advance(J){if(!J)return;let Q=J.split(`
`);if(Q.length>1){for(let X=0;X<Q.length-1;X++)this.generatedCodeLine++,this.raw[this.generatedCodeLine]=this.rawSegments=[];this.generatedCodeColumn=0}this.generatedCodeColumn+=Q[Q.length-1].length}}var f=`
`,V={insertLeft:!1,insertRight:!1,storeName:!1};class k{constructor(J,Q={}){let X=new w(0,J.length,J);Object.defineProperties(this,{original:{writable:!0,value:J},outro:{writable:!0,value:""},intro:{writable:!0,value:""},firstChunk:{writable:!0,value:X},lastChunk:{writable:!0,value:X},lastSearchedChunk:{writable:!0,value:X},byStart:{writable:!0,value:{}},byEnd:{writable:!0,value:{}},filename:{writable:!0,value:Q.filename},indentExclusionRanges:{writable:!0,value:Q.indentExclusionRanges},sourcemapLocations:{writable:!0,value:new x},storedNames:{writable:!0,value:{}},indentStr:{writable:!0,value:void 0},ignoreList:{writable:!0,value:Q.ignoreList},offset:{writable:!0,value:Q.offset||0}}),this.byStart[0]=X,this.byEnd[J.length]=X}addSourcemapLocation(J){this.sourcemapLocations.add(J)}append(J){if(typeof J!=="string")throw new TypeError("outro content must be a string");return this.outro+=J,this}appendLeft(J,Q){if(J=J+this.offset,typeof Q!=="string")throw new TypeError("inserted content must be a string");this._split(J);let X=this.byEnd[J];if(X)X.appendLeft(Q);else this.intro+=Q;return this}appendRight(J,Q){if(J=J+this.offset,typeof Q!=="string")throw new TypeError("inserted content must be a string");this._split(J);let X=this.byStart[J];if(X)X.appendRight(Q);else this.outro+=Q;return this}clone(){let J=new k(this.original,{filename:this.filename,offset:this.offset}),Q=this.firstChunk,X=J.firstChunk=J.lastSearchedChunk=Q.clone();while(Q){J.byStart[X.start]=X,J.byEnd[X.end]=X;let Z=Q.next,$=Z&&Z.clone();if($)X.next=$,$.previous=X,X=$;Q=Z}if(J.lastChunk=X,this.indentExclusionRanges)J.indentExclusionRanges=this.indentExclusionRanges.slice();return J.sourcemapLocations=new x(this.sourcemapLocations),J.intro=this.intro,J.outro=this.outro,J}generateDecodedMap(J){J=J||{};let Q=0,X=Object.keys(this.storedNames),Z=new e(J.hires),$=t(this.original);if(this.intro)Z.advance(this.intro);if(this.firstChunk.eachNext((Y)=>{let z=$(Y.start);if(Y.intro.length)Z.advance(Y.intro);if(Y.edited)Z.addEdit(Q,Y.content,z,Y.storeName?X.indexOf(Y.original):-1);else Z.addUneditedChunk(Q,Y,this.original,z,this.sourcemapLocations);if(Y.outro.length)Z.advance(Y.outro)}),this.outro)Z.advance(this.outro);return{file:J.file?J.file.split(/[/\\]/).pop():void 0,sources:[J.source?AJ(J.file||"",J.source):J.file||""],sourcesContent:J.includeContent?[this.original]:void 0,names:X,mappings:Z.raw,x_google_ignoreList:this.ignoreList?[Q]:void 0}}generateMap(J){return new n(this.generateDecodedMap(J))}_ensureindentStr(){if(this.indentStr===void 0)this.indentStr=qJ(this.original)}_getRawIndentString(){return this._ensureindentStr(),this.indentStr}getIndentString(){return this._ensureindentStr(),this.indentStr===null?"\t":this.indentStr}indent(J,Q){let X=/^[^\r\n]/gm;if(UJ(J))Q=J,J=void 0;if(J===void 0)this._ensureindentStr(),J=this.indentStr||"\t";if(J==="")return this;Q=Q||{};let Z={};if(Q.exclude)(typeof Q.exclude[0]==="number"?[Q.exclude]:Q.exclude).forEach((q)=>{for(let A=q[0];A<q[1];A+=1)Z[A]=!0});let $=Q.indentStart!==!1,Y=(W)=>{if($)return`${J}${W}`;return $=!0,W};this.intro=this.intro.replace(X,Y);let z=0,F=this.firstChunk;while(F){let W=F.end;if(F.edited){if(!Z[z]){if(F.content=F.content.replace(X,Y),F.content.length)$=F.content[F.content.length-1]===`
`}}else{z=F.start;while(z<W){if(!Z[z]){let q=this.original[z];if(q===`
`)$=!0;else if(q!=="\r"&&$)if($=!1,z===F.start)F.prependRight(J);else this._splitChunk(F,z),F=F.next,F.prependRight(J)}z+=1}}z=F.end,F=F.next}return this.outro=this.outro.replace(X,Y),this}insert(){throw new Error("magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)")}insertLeft(J,Q){if(!V.insertLeft)console.warn("magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead"),V.insertLeft=!0;return this.appendLeft(J,Q)}insertRight(J,Q){if(!V.insertRight)console.warn("magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead"),V.insertRight=!0;return this.prependRight(J,Q)}move(J,Q,X){if(J=J+this.offset,Q=Q+this.offset,X=X+this.offset,X>=J&&X<=Q)throw new Error("Cannot move a selection inside itself");this._split(J),this._split(Q),this._split(X);let Z=this.byStart[J],$=this.byEnd[Q],Y=Z.previous,z=$.next,F=this.byStart[X];if(!F&&$===this.lastChunk)return this;let W=F?F.previous:this.lastChunk;if(Y)Y.next=z;if(z)z.previous=Y;if(W)W.next=Z;if(F)F.previous=$;if(!Z.previous)this.firstChunk=$.next;if(!$.next)this.lastChunk=Z.previous,this.lastChunk.next=null;if(Z.previous=W,$.next=F||null,!W)this.firstChunk=Z;if(!F)this.lastChunk=$;return this}overwrite(J,Q,X,Z){return Z=Z||{},this.update(J,Q,X,{...Z,overwrite:!Z.contentOnly})}update(J,Q,X,Z){if(J=J+this.offset,Q=Q+this.offset,typeof X!=="string")throw new TypeError("replacement content must be a string");if(this.original.length!==0){while(J<0)J+=this.original.length;while(Q<0)Q+=this.original.length}if(Q>this.original.length)throw new Error("end is out of bounds");if(J===Q)throw new Error("Cannot overwrite a zero-length range – use appendLeft or prependRight instead");if(this._split(J),this._split(Q),Z===!0){if(!V.storeName)console.warn("The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string"),V.storeName=!0;Z={storeName:!0}}let $=Z!==void 0?Z.storeName:!1,Y=Z!==void 0?Z.overwrite:!1;if($){let W=this.original.slice(J,Q);Object.defineProperty(this.storedNames,W,{writable:!0,value:!0,enumerable:!0})}let z=this.byStart[J],F=this.byEnd[Q];if(z){let W=z;while(W!==F){if(W.next!==this.byStart[W.end])throw new Error("Cannot overwrite across a split point");W=W.next,W.edit("",!1)}z.edit(X,$,!Y)}else{let W=new w(J,Q,"").edit(X,$);F.next=W,W.previous=F}return this}prepend(J){if(typeof J!=="string")throw new TypeError("outro content must be a string");return this.intro=J+this.intro,this}prependLeft(J,Q){if(J=J+this.offset,typeof Q!=="string")throw new TypeError("inserted content must be a string");this._split(J);let X=this.byEnd[J];if(X)X.prependLeft(Q);else this.intro=Q+this.intro;return this}prependRight(J,Q){if(J=J+this.offset,typeof Q!=="string")throw new TypeError("inserted content must be a string");this._split(J);let X=this.byStart[J];if(X)X.prependRight(Q);else this.outro=Q+this.outro;return this}remove(J,Q){if(J=J+this.offset,Q=Q+this.offset,this.original.length!==0){while(J<0)J+=this.original.length;while(Q<0)Q+=this.original.length}if(J===Q)return this;if(J<0||Q>this.original.length)throw new Error("Character is out of bounds");if(J>Q)throw new Error("end must be greater than start");this._split(J),this._split(Q);let X=this.byStart[J];while(X)X.intro="",X.outro="",X.edit(""),X=Q>X.end?this.byStart[X.end]:null;return this}reset(J,Q){if(J=J+this.offset,Q=Q+this.offset,this.original.length!==0){while(J<0)J+=this.original.length;while(Q<0)Q+=this.original.length}if(J===Q)return this;if(J<0||Q>this.original.length)throw new Error("Character is out of bounds");if(J>Q)throw new Error("end must be greater than start");this._split(J),this._split(Q);let X=this.byStart[J];while(X)X.reset(),X=Q>X.end?this.byStart[X.end]:null;return this}lastChar(){if(this.outro.length)return this.outro[this.outro.length-1];let J=this.lastChunk;do{if(J.outro.length)return J.outro[J.outro.length-1];if(J.content.length)return J.content[J.content.length-1];if(J.intro.length)return J.intro[J.intro.length-1]}while(J=J.previous);if(this.intro.length)return this.intro[this.intro.length-1];return""}lastLine(){let J=this.outro.lastIndexOf(f);if(J!==-1)return this.outro.substr(J+1);let Q=this.outro,X=this.lastChunk;do{if(X.outro.length>0){if(J=X.outro.lastIndexOf(f),J!==-1)return X.outro.substr(J+1)+Q;Q=X.outro+Q}if(X.content.length>0){if(J=X.content.lastIndexOf(f),J!==-1)return X.content.substr(J+1)+Q;Q=X.content+Q}if(X.intro.length>0){if(J=X.intro.lastIndexOf(f),J!==-1)return X.intro.substr(J+1)+Q;Q=X.intro+Q}}while(X=X.previous);if(J=this.intro.lastIndexOf(f),J!==-1)return this.intro.substr(J+1)+Q;return this.intro+Q}slice(J=0,Q=this.original.length-this.offset){if(J=J+this.offset,Q=Q+this.offset,this.original.length!==0){while(J<0)J+=this.original.length;while(Q<0)Q+=this.original.length}let X="",Z=this.firstChunk;while(Z&&(Z.start>J||Z.end<=J)){if(Z.start<Q&&Z.end>=Q)return X;Z=Z.next}if(Z&&Z.edited&&Z.start!==J)throw new Error(`Cannot use replaced character ${J} as slice start anchor.`);let $=Z;while(Z){if(Z.intro&&($!==Z||Z.start===J))X+=Z.intro;let Y=Z.start<Q&&Z.end>=Q;if(Y&&Z.edited&&Z.end!==Q)throw new Error(`Cannot use replaced character ${Q} as slice end anchor.`);let z=$===Z?J-Z.start:0,F=Y?Z.content.length+Q-Z.end:Z.content.length;if(X+=Z.content.slice(z,F),Z.outro&&(!Y||Z.end===Q))X+=Z.outro;if(Y)break;Z=Z.next}return X}snip(J,Q){let X=this.clone();return X.remove(0,J),X.remove(Q,X.original.length),X}_split(J){if(this.byStart[J]||this.byEnd[J])return;let Q=this.lastSearchedChunk,X=Q,Z=J>Q.end;while(Q){if(Q.contains(J))return this._splitChunk(Q,J);if(Q=Z?this.byStart[Q.end]:this.byEnd[Q.start],Q===X)return;X=Q}}_splitChunk(J,Q){if(J.edited&&J.content.length){let Z=t(this.original)(Q);throw new Error(`Cannot split a chunk that has already been edited (${Z.line}:${Z.column} – "${J.original}")`)}let X=J.split(Q);if(this.byEnd[Q]=J,this.byStart[Q]=X,this.byEnd[X.end]=X,J===this.lastChunk)this.lastChunk=X;return this.lastSearchedChunk=J,!0}toString(){let J=this.intro,Q=this.firstChunk;while(Q)J+=Q.toString(),Q=Q.next;return J+this.outro}isEmpty(){let J=this.firstChunk;do if(J.intro.length&&J.intro.trim()||J.content.length&&J.content.trim()||J.outro.length&&J.outro.trim())return!1;while(J=J.next);return!0}length(){let J=this.firstChunk,Q=0;do Q+=J.intro.length+J.content.length+J.outro.length;while(J=J.next);return Q}trimLines(){return this.trim("[\\r\\n]")}trim(J){return this.trimStart(J).trimEnd(J)}trimEndAborted(J){let Q=new RegExp((J||"\\s")+"+$");if(this.outro=this.outro.replace(Q,""),this.outro.length)return!0;let X=this.lastChunk;do{let Z=X.end,$=X.trimEnd(Q);if(X.end!==Z){if(this.lastChunk===X)this.lastChunk=X.next;this.byEnd[X.end]=X,this.byStart[X.next.start]=X.next,this.byEnd[X.next.end]=X.next}if($)return!0;X=X.previous}while(X);return!1}trimEnd(J){return this.trimEndAborted(J),this}trimStartAborted(J){let Q=new RegExp("^"+(J||"\\s")+"+");if(this.intro=this.intro.replace(Q,""),this.intro.length)return!0;let X=this.firstChunk;do{let Z=X.end,$=X.trimStart(Q);if(X.end!==Z){if(X===this.lastChunk)this.lastChunk=X.next;this.byEnd[X.end]=X,this.byStart[X.next.start]=X.next,this.byEnd[X.next.end]=X.next}if($)return!0;X=X.next}while(X);return!1}trimStart(J){return this.trimStartAborted(J),this}hasChanged(){return this.original!==this.toString()}_replaceRegexp(J,Q){function X($,Y){if(typeof Q==="string")return Q.replace(/\$(\$|&|\d+)/g,(z,F)=>{if(F==="$")return"$";if(F==="&")return $[0];if(+F<$.length)return $[+F];return`$${F}`});else return Q(...$,$.index,Y,$.groups)}function Z($,Y){let z,F=[];while(z=$.exec(Y))F.push(z);return F}if(J.global)Z(J,this.original).forEach((Y)=>{if(Y.index!=null){let z=X(Y,this.original);if(z!==Y[0])this.overwrite(Y.index,Y.index+Y[0].length,z)}});else{let $=this.original.match(J);if($&&$.index!=null){let Y=X($,this.original);if(Y!==$[0])this.overwrite($.index,$.index+$[0].length,Y)}}return this}_replaceString(J,Q){let{original:X}=this,Z=X.indexOf(J);if(Z!==-1){if(typeof Q==="function")Q=Q(J,Z,X);if(J!==Q)this.overwrite(Z,Z+J.length,Q)}return this}replace(J,Q){if(typeof J==="string")return this._replaceString(J,Q);return this._replaceRegexp(J,Q)}_replaceAllString(J,Q){let{original:X}=this,Z=J.length;for(let $=X.indexOf(J);$!==-1;$=X.indexOf(J,$+Z)){let Y=X.slice($,$+Z),z=Q;if(typeof Q==="function")z=Q(Y,$,X);if(Y!==z)this.overwrite($,$+Z,z)}return this}replaceAll(J,Q){if(typeof J==="string")return this._replaceAllString(J,Q);if(!J.global)throw new TypeError("MagicString.prototype.replaceAll called with a non-global RegExp argument");return this._replaceRegexp(J,Q)}}function l(J=""){let Q=J.length,X=Q^Q,Z=0,$;while(Q>=4)$=J.charCodeAt(Z)&255|(J.charCodeAt(++Z)&255)<<8|(J.charCodeAt(++Z)&255)<<16|(J.charCodeAt(++Z)&255)<<24,$=($&65535)*1540483477+((($>>>16)*1540483477&65535)<<16),$^=$>>>24,$=($&65535)*1540483477+((($>>>16)*1540483477&65535)<<16),X=(X&65535)*1540483477+(((X>>>16)*1540483477&65535)<<16)^$,Q-=4,++Z;if(Q>=3)X^=(J.charCodeAt(Z+2)&255)<<16;if(Q>=2)X^=(J.charCodeAt(Z+1)&255)<<8;if(Q>=1)X^=J.charCodeAt(Z)&255,X=(X&65535)*1540483477+(((X>>>16)*1540483477&65535)<<16);return X^=X>>>13,X=(X&65535)*1540483477+(((X>>>16)*1540483477&65535)<<16),X^=X>>>15,(X>>>0).toString(36)}function d(J){return/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(J)}function T(J){return JSON.stringify(J)}function jJ(J={}){let{classPrefix:Q="ss",debug:X}=J,Z=X??process.env.DEBUG_STYLED_STATIC==="true",$=new Map,Y,z=!1;return{name:"styled-static",enforce:"post",configResolved(F){Y=F,z=Y.command==="serve"},resolveId(F){if(F.startsWith("virtual:styled-static/"))return"\x00"+F;if(F.startsWith("\x00virtual:styled-static/"))return F;return null},load(F){if(F.startsWith("\x00virtual:styled-static/")){let q=F.slice(1).replace(/\.(css|js)$/,".css"),A=$.get(q),H=A?.css??"";if(z){let G=A?.sourceFile??"",K=G?`${H}
/*# sourceURL=${G} */`:H;return`
const id = ${JSON.stringify(q)};
const css = ${JSON.stringify(K)};

// Remove existing style for this module (HMR cleanup)
const existing = document.querySelector(\`style[data-ss-id="\${id}"]\`);
if (existing) existing.remove();

const style = document.createElement('style');
style.setAttribute('data-ss-id', id);
style.textContent = css;
document.head.appendChild(style);

if (import.meta.hot) {
  import.meta.hot.accept();
}

export default css;
`}return H}return null},handleHotUpdate({file:F,server:W}){if(/\.[tj]sx?$/.test(F)){let q=u(F);for(let[A]of $)if(A.includes(q)){let H=W.moduleGraph.getModuleById(`\x00${A}`);if(H)W.moduleGraph.invalidateModule(H)}}},async transform(F,W){if(!/\.[cm]?[jt]sx?$/.test(W)||/node_modules/.test(W))return null;let q=F.includes("styled-static"),A=F.includes('from "./index"')||F.includes("from './index'")||F.includes('from "../index"')||F.includes("from '../index'");if(!q&&!A)return null;if(Z)console.log("[styled-static] Transforming:",W);let H;try{if(H=this.parse(F),Z)console.log("[styled-static] AST parsed successfully, body length:",H.body.length)}catch(U){if(Z)console.log("[styled-static] AST parse error:",U);return null}let G=_J(H);if(Z)console.log("[styled-static] Found imports:",G);let K=G.css||G.styled||G.createGlobalStyle||G.keyframes,_=G.styledVariants||G.cssVariants,O=!!G.withComponent;if(!K&&!_&&!O){if(Z)console.log("[styled-static] No imports found, skipping");return null}let j=K?OJ(H,G,F):[];if(Z)console.log("[styled-static] Found templates:",j.length);let R=_?RJ(H,F,G):[];if(Z)console.log("[styled-static] Found variant calls:",R.length);let P=O?VJ(H,G):[];if(Z)console.log("[styled-static] Found withComponent calls:",P.length);if(j.length===0&&R.length===0&&P.length===0){if(Z)console.log("[styled-static] No templates, variants, or withComponent found, skipping");return null}let D=new k(F),S=[],v=!1,c=0;for(let U=0;U<j.length;U++){let B=j[U];if(!B)continue;let E=BJ(F,B.node.quasi),y=z?6:8,I=l(E).slice(0,y),L=`${Q}-${I}`,m=B.type==="createGlobalStyle"?E:`.${L} { ${E} }`,C=`virtual:styled-static/${u(W)}/${c++}`,N=`${C}.css`,h=z?`${C}.js`:N;$.set(N,{css:m,sourceFile:W}),S.push(`import "${h}";`);let p=EJ(B,L,z);if(D.overwrite(B.node.start,B.node.end,p),B.type==="styled"||B.type==="styledExtend"||B.type==="styledAttrs")v=!0}let g=[];for(let U of R){let B=l(U.baseCss||"").slice(0,6),E=`${Q}-${B}`,y="";if(U.baseCss)y+=`.${E} { ${U.baseCss} }
`;for(let[h,p]of U.variants)for(let[QJ,XJ]of p){let ZJ=`${E}--${h}-${QJ}`;y+=`.${ZJ} { ${XJ} }
`}let I=`virtual:styled-static/${u(W)}/${c++}`,L=`${I}.css`,m=z?`${I}.js`:L;$.set(L,{css:y,sourceFile:W}),S.push(`import "${m}";`);let C=Array.from(U.variants.keys()),N=NJ(U,E,C,z);if(D.overwrite(U.start,U.end,N.code),N.hoisted)g.push(N.hoisted);if(U.type==="styledVariants")v=!0}for(let U of P){if(!d(U.fromComponent))throw new Error(`[styled-static] Invalid fromComponent name: ${U.fromComponent}`);let B=/^[a-z]/.test(U.toComponent),E;if(B)E=`Object.assign((p) => createElement(${T(U.toComponent)}, {...p, className: m(${U.fromComponent}.className, p.className)}), { className: ${U.fromComponent}.className })`;else{if(!d(U.toComponent))throw new Error(`[styled-static] Invalid toComponent name: ${U.toComponent}`);E=`Object.assign((p) => createElement(${U.toComponent}, {...p, className: m(${U.fromComponent}.className, p.className)}), { className: ${U.fromComponent}.className })`}D.overwrite(U.start,U.end,E),v=!0}let JJ=G.source==="./index"||G.source==="../index"?G.source.replace("/index","/runtime"):"styled-static/runtime",M="";if(S.length>0)M+=S.join(`
`)+`
`;if(v)M+=`import { createElement } from "react";
`,M+=`import { m } from "${JJ}";
`;if(g.length>0)M+=g.join(`
`)+`
`;if(M)D.prepend(M+`
`);return{code:D.toString(),map:D.generateMap({hires:!0})}}}}function _J(J){let Q={};for(let X of J.body)if(X.type==="ImportDeclaration"){let Z=X.source.value;if(Z==="styled-static"||Z==="./index"||Z==="../index"){Q.source=Z;for(let Y of X.specifiers)if(Y.type==="ImportSpecifier"){let z=Y.imported.name,F=Y.local.name;if(z==="styled")Q.styled=F;if(z==="css")Q.css=F;if(z==="createGlobalStyle")Q.createGlobalStyle=F;if(z==="keyframes")Q.keyframes=F;if(z==="styledVariants")Q.styledVariants=F;if(z==="cssVariants")Q.cssVariants=F;if(z==="withComponent")Q.withComponent=F}}}return Q}function OJ(J,Q,X){let Z=[];function $(Y){for(let z of Y.declarations)if(z.init?.type==="TaggedTemplateExpression"&&z.id.type==="Identifier"){let F=z.init,W=z.id.name,q=DJ(F,Q,W,X);if(q)Z.push(q)}}for(let Y of J.body){if(Y.type==="VariableDeclaration")$(Y);if(Y.type==="ExportNamedDeclaration"&&Y.declaration?.type==="VariableDeclaration")$(Y.declaration)}return Z}function DJ(J,Q,X,Z){let{tag:$}=J;if($.type==="MemberExpression"&&$.object.type==="Identifier"&&$.object.name===Q.styled&&$.property.type==="Identifier")return{type:"styled",node:J,tag:$.property.name,variableName:X};if($.type==="CallExpression"&&$.callee.type==="Identifier"&&$.callee.name===Q.styled&&$.arguments[0]?.type==="Identifier")return{type:"styledExtend",node:J,tag:"",baseComponent:$.arguments[0].name,variableName:X};if($.type==="Identifier"&&$.name===Q.css)return{type:"css",node:J,tag:"",variableName:X};if($.type==="Identifier"&&$.name===Q.createGlobalStyle)return{type:"createGlobalStyle",node:J,tag:"",variableName:X};if($.type==="Identifier"&&$.name===Q.keyframes)return{type:"keyframes",node:J,tag:"",variableName:X};if($.type==="CallExpression"&&$.callee.type==="MemberExpression"&&$.callee.property.type==="Identifier"&&$.callee.property.name==="attrs"&&$.callee.object.type==="MemberExpression"&&$.callee.object.object.type==="Identifier"&&$.callee.object.object.name===Q.styled&&$.callee.object.property.type==="Identifier"&&$.arguments.length===1){let Y=$.callee.object.property.name,z=$.arguments[0],F=Z.slice(z.start,z.end);return{type:"styledAttrs",node:J,tag:Y,variableName:X,attrsArg:F}}return null}function BJ(J,Q){return J.slice(Q.start+1,Q.end-1)}function EJ(J,Q,X){let Z=T(Q);switch(J.type){case"styled":return`Object.assign((p) => createElement(${T(J.tag)}, {...p, className: m(${Z}, p.className)}), { className: ${Z} })`;case"styledExtend":return`Object.assign((p) => createElement(${J.baseComponent}, {...p, className: m(${Z}, p.className)}), { className: ${J.baseComponent}.className + " " + ${Z} })`;case"styledAttrs":return`Object.assign((p) => createElement(${T(J.tag)}, {...(${J.attrsArg??"{}"}), ...p, className: m(${Z}, p.className)}), { className: ${Z} })`;case"css":return Z;case"keyframes":return Z;case"createGlobalStyle":return"() => null"}}function u(J){return J.replace(/\\/g,"/").replace(/^\/+/,"").toLowerCase()}function RJ(J,Q,X){let Z=[];function $(Y){for(let z of Y.declarations)if(z.init?.type==="CallExpression"&&z.id.type==="Identifier"){let F=z.init,W=z.id.name,q=TJ(F,Q,X,W);if(q)Z.push(q)}}for(let Y of J.body){if(Y.type==="VariableDeclaration")$(Y);if(Y.type==="ExportNamedDeclaration"&&Y.declaration?.type==="VariableDeclaration")$(Y.declaration)}return Z}function TJ(J,Q,X,Z){if(J.callee.type!=="Identifier")return null;let $=J.callee.name,Y=$===X.styledVariants,z=$===X.cssVariants;if(!Y&&!z)return null;if(J.arguments.length!==1||J.arguments[0]?.type!=="ObjectExpression")return null;let F=J.arguments[0],W,q,A=new Map;for(let H of F.properties){if(H.type!=="Property"||H.key.type!=="Identifier")continue;let G=H.key.name;if(G==="component"){if(H.value.type==="Literal"&&typeof H.value.value==="string")W=H.value.value;else if(H.value.type==="Identifier")W=H.value.name}if(G==="css"){if(H.value.type==="Literal"&&typeof H.value.value==="string")q=H.value.value;else if(H.value.type==="TemplateLiteral"){let K=H.value;q=Q.slice(K.start+1,K.end-1)}else if(H.value.type==="TaggedTemplateExpression"){let K=H.value;if(K.tag.type==="Identifier"&&K.tag.name===X.css)q=Q.slice(K.quasi.start+1,K.quasi.end-1)}}if(G==="variants"&&H.value.type==="ObjectExpression")for(let K of H.value.properties){if(K.type!=="Property"||K.key.type!=="Identifier")continue;if(K.value.type!=="ObjectExpression")continue;let _=K.key.name,O=new Map;for(let j of K.value.properties){if(j.type!=="Property"||j.key.type!=="Identifier")continue;let R=j.key.name,P;if(j.value.type==="Literal"&&typeof j.value.value==="string")P=j.value.value;else if(j.value.type==="TemplateLiteral"){let D=j.value;P=Q.slice(D.start+1,D.end-1)}else if(j.value.type==="TaggedTemplateExpression"){let D=j.value;if(D.tag.type==="Identifier"&&D.tag.name===X.css)P=Q.slice(D.quasi.start+1,D.quasi.end-1)}if(P)O.set(R,P)}if(O.size>0)A.set(_,O)}}return{type:Y?"styledVariants":"cssVariants",start:J.start,end:J.end,component:W,baseCss:q,variants:A,variableName:Z}}var PJ=4,MJ=0;function NJ(J,Q,X,Z){let $=T(Q),Y=J.type==="cssVariants",F=X.reduce((H,G)=>H+(J.variants.get(G)?.size??0),0)>PJ,W=X.length>0?`{ ${X.join(", ")}, className, ...p }`:"{ className, ...p }",q,A;if(F&&X.length>0){let H=`_vm${MJ++}`,G=X.map((_)=>{let O=J.variants.get(_);if(!O)return"";let j=Array.from(O.keys()).map((R)=>`${T(R)}:${T(` ${Q}--${_}-${R}`)}`).join(",");return`${_}:{${j}}`});A=`const ${H}={${G.join(",")}};`,q=X.map((_)=>{let O=Y?`variants.${_}`:_;return`c+=${H}.${_}[${O}]||""`}).join(";")+";"}else{let H=[];for(let G of X){let K=J.variants.get(G);if(K){let _=Y?`variants.${G}`:G,O=Array.from(K.keys()).map((j,R)=>`${R===0?"if":"else if"} (${_} === ${T(j)}) c += ${T(` ${Q}--${G}-${j}`)}`).join("; ");if(O)H.push(O)}}q=H.length>0?H.join("; ")+"; ":""}if(J.type==="styledVariants")if(J.component&&/^[a-z]/.test(J.component)){if(!J.component||!/^[a-z][a-z0-9]*$/.test(J.component))throw new Error(`[styled-static] Invalid HTML tag name: ${J.component}`);let G=T(J.component);return{code:`Object.assign((${W}) => { let c = ${$}; ${q}return createElement(${G}, {...p, className: m(c, className)}); }, { className: ${$} })`,hoisted:A}}else{if(!J.component||!d(J.component))throw new Error(`[styled-static] Invalid component name: ${J.component}`);return{code:`Object.assign((${W}) => { let c = ${$}; ${q}return createElement(${J.component}, {...p, className: m(c, className)}); }, { className: ${J.component}.className + " " + ${$} })`,hoisted:A}}return{code:`(variants) => { let c = ${$}; ${q}return c; }`,hoisted:A}}function VJ(J,Q){let X=[];function Z($){for(let Y of $.declarations)if(Y.init?.type==="CallExpression"&&Y.id.type==="Identifier"){let z=Y.init,F=Y.id.name;if(z.callee.type==="Identifier"&&z.callee.name===Q.withComponent&&z.arguments.length===2){let W=z.arguments[0],q=z.arguments[1],A,H;if(W?.type==="Literal"&&typeof W.value==="string")A=W.value;else if(W?.type==="Identifier")A=W.name;if(q?.type==="Identifier")H=q.name;if(A&&H)X.push({start:z.start,end:z.end,toComponent:A,fromComponent:H,variableName:F})}}}for(let $ of J.body){if($.type==="VariableDeclaration")Z($);if($.type==="ExportNamedDeclaration"&&$.declaration?.type==="VariableDeclaration")Z($.declaration)}return X}var CJ=jJ;export{jJ as styledStatic,CJ as default};
