var XJ=44,ZJ=59,u="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",o=new Uint8Array(64),$J=new Uint8Array(128);for(let J=0;J<u.length;J++){let Q=u.charCodeAt(J);o[J]=Q,$J[Q]=J}function y(J,Q,X){let Z=Q-X;Z=Z<0?-Z<<1|1:Z<<1;do{let $=Z&31;if(Z>>>=5,Z>0)$|=32;J.write(o[$])}while(Z>0);return Q}var d=16384,c=typeof TextDecoder!=="undefined"?new TextDecoder:typeof Buffer!=="undefined"?{decode(J){return Buffer.from(J.buffer,J.byteOffset,J.byteLength).toString()}}:{decode(J){let Q="";for(let X=0;X<J.length;X++)Q+=String.fromCharCode(J[X]);return Q}},zJ=class{constructor(){this.pos=0,this.out="",this.buffer=new Uint8Array(d)}write(J){let{buffer:Q}=this;if(Q[this.pos++]=J,this.pos===d)this.out+=c.decode(Q),this.pos=0}flush(){let{buffer:J,out:Q,pos:X}=this;return X>0?Q+c.decode(J.subarray(0,X)):Q}};function i(J){let Q=new zJ,X=0,Z=0,$=0,Y=0;for(let F=0;F<J.length;F++){let z=J[F];if(F>0)Q.write(ZJ);if(z.length===0)continue;let W=0;for(let K=0;K<z.length;K++){let H=z[K];if(K>0)Q.write(XJ);if(W=y(Q,H[0],W),H.length===1)continue;if(X=y(Q,H[1],X),Z=y(Q,H[2],Z),$=y(Q,H[3],$),H.length===4)continue;Y=y(Q,H[4],Y)}}return Q.flush()}class x{constructor(J){this.bits=J instanceof x?J.bits.slice():[]}add(J){this.bits[J>>5]|=1<<(J&31)}has(J){return!!(this.bits[J>>5]&1<<(J&31))}}class b{constructor(J,Q,X){this.start=J,this.end=Q,this.original=X,this.intro="",this.outro="",this.content=X,this.storeName=!1,this.edited=!1,this.previous=null,this.next=null}appendLeft(J){this.outro+=J}appendRight(J){this.intro=this.intro+J}clone(){let J=new b(this.start,this.end,this.original);return J.intro=this.intro,J.outro=this.outro,J.content=this.content,J.storeName=this.storeName,J.edited=this.edited,J}contains(J){return this.start<J&&J<this.end}eachNext(J){let Q=this;while(Q)J(Q),Q=Q.next}eachPrevious(J){let Q=this;while(Q)J(Q),Q=Q.previous}edit(J,Q,X){if(this.content=J,!X)this.intro="",this.outro="";return this.storeName=Q,this.edited=!0,this}prependLeft(J){this.outro=J+this.outro}prependRight(J){this.intro=J+this.intro}reset(){if(this.intro="",this.outro="",this.edited)this.content=this.original,this.storeName=!1,this.edited=!1}split(J){let Q=J-this.start,X=this.original.slice(0,Q),Z=this.original.slice(Q);this.original=X;let $=new b(J,this.end,Z);if($.outro=this.outro,this.outro="",this.end=J,this.edited)$.edit("",!1),this.content="";else this.content=X;if($.next=this.next,$.next)$.next.previous=$;return $.previous=this,this.next=$,$}toString(){return this.intro+this.content+this.outro}trimEnd(J){if(this.outro=this.outro.replace(J,""),this.outro.length)return!0;let Q=this.content.replace(J,"");if(Q.length){if(Q!==this.content){if(this.split(this.start+Q.length).edit("",void 0,!0),this.edited)this.edit(Q,this.storeName,!0)}return!0}else if(this.edit("",void 0,!0),this.intro=this.intro.replace(J,""),this.intro.length)return!0}trimStart(J){if(this.intro=this.intro.replace(J,""),this.intro.length)return!0;let Q=this.content.replace(J,"");if(Q.length){if(Q!==this.content){let X=this.split(this.end-Q.length);if(this.edited)X.edit(Q,this.storeName,!0);this.edit("",void 0,!0)}return!0}else if(this.edit("",void 0,!0),this.outro=this.outro.replace(J,""),this.outro.length)return!0}}function YJ(){if(typeof globalThis!=="undefined"&&typeof globalThis.btoa==="function")return(J)=>globalThis.btoa(unescape(encodeURIComponent(J)));else if(typeof Buffer==="function")return(J)=>Buffer.from(J,"utf-8").toString("base64");else return()=>{throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.")}}var FJ=YJ();class s{constructor(J){if(this.version=3,this.file=J.file,this.sources=J.sources,this.sourcesContent=J.sourcesContent,this.names=J.names,this.mappings=i(J.mappings),typeof J.x_google_ignoreList!=="undefined")this.x_google_ignoreList=J.x_google_ignoreList;if(typeof J.debugId!=="undefined")this.debugId=J.debugId}toString(){return JSON.stringify(this)}toUrl(){return"data:application/json;charset=utf-8;base64,"+FJ(this.toString())}}function WJ(J){let Q=J.split(`
`),X=Q.filter((Y)=>/^\t+/.test(Y)),Z=Q.filter((Y)=>/^ {2,}/.test(Y));if(X.length===0&&Z.length===0)return null;if(X.length>=Z.length)return"\t";let $=Z.reduce((Y,F)=>{let z=/^ +/.exec(F)[0].length;return Math.min(z,Y)},1/0);return new Array($+1).join(" ")}function KJ(J,Q){let X=J.split(/[/\\]/),Z=Q.split(/[/\\]/);X.pop();while(X[0]===Z[0])X.shift(),Z.shift();if(X.length){let $=X.length;while($--)X[$]=".."}return X.concat(Z).join("/")}var AJ=Object.prototype.toString;function HJ(J){return AJ.call(J)==="[object Object]"}function a(J){let Q=J.split(`
`),X=[];for(let Z=0,$=0;Z<Q.length;Z++)X.push($),$+=Q[Z].length+1;return function Z($){let Y=0,F=X.length;while(Y<F){let K=Y+F>>1;if($<X[K])F=K;else Y=K+1}let z=Y-1,W=$-X[z];return{line:z,column:W}}}var qJ=/\w/;class r{constructor(J){this.hires=J,this.generatedCodeLine=0,this.generatedCodeColumn=0,this.raw=[],this.rawSegments=this.raw[this.generatedCodeLine]=[],this.pending=null}addEdit(J,Q,X,Z){if(Q.length){let $=Q.length-1,Y=Q.indexOf(`
`,0),F=-1;while(Y>=0&&$>Y){let W=[this.generatedCodeColumn,J,X.line,X.column];if(Z>=0)W.push(Z);this.rawSegments.push(W),this.generatedCodeLine+=1,this.raw[this.generatedCodeLine]=this.rawSegments=[],this.generatedCodeColumn=0,F=Y,Y=Q.indexOf(`
`,Y+1)}let z=[this.generatedCodeColumn,J,X.line,X.column];if(Z>=0)z.push(Z);this.rawSegments.push(z),this.advance(Q.slice(F+1))}else if(this.pending)this.rawSegments.push(this.pending),this.advance(Q);this.pending=null}addUneditedChunk(J,Q,X,Z,$){let Y=Q.start,F=!0,z=!1;while(Y<Q.end){if(X[Y]===`
`)Z.line+=1,Z.column=0,this.generatedCodeLine+=1,this.raw[this.generatedCodeLine]=this.rawSegments=[],this.generatedCodeColumn=0,F=!0,z=!1;else{if(this.hires||F||$.has(Y)){let W=[this.generatedCodeColumn,J,Z.line,Z.column];if(this.hires==="boundary")if(qJ.test(X[Y])){if(!z)this.rawSegments.push(W),z=!0}else this.rawSegments.push(W),z=!1;else this.rawSegments.push(W)}Z.column+=1,this.generatedCodeColumn+=1,F=!1}Y+=1}this.pending=null}advance(J){if(!J)return;let Q=J.split(`
`);if(Q.length>1){for(let X=0;X<Q.length-1;X++)this.generatedCodeLine++,this.raw[this.generatedCodeLine]=this.rawSegments=[];this.generatedCodeColumn=0}this.generatedCodeColumn+=Q[Q.length-1].length}}var L=`
`,M={insertLeft:!1,insertRight:!1,storeName:!1};class k{constructor(J,Q={}){let X=new b(0,J.length,J);Object.defineProperties(this,{original:{writable:!0,value:J},outro:{writable:!0,value:""},intro:{writable:!0,value:""},firstChunk:{writable:!0,value:X},lastChunk:{writable:!0,value:X},lastSearchedChunk:{writable:!0,value:X},byStart:{writable:!0,value:{}},byEnd:{writable:!0,value:{}},filename:{writable:!0,value:Q.filename},indentExclusionRanges:{writable:!0,value:Q.indentExclusionRanges},sourcemapLocations:{writable:!0,value:new x},storedNames:{writable:!0,value:{}},indentStr:{writable:!0,value:void 0},ignoreList:{writable:!0,value:Q.ignoreList},offset:{writable:!0,value:Q.offset||0}}),this.byStart[0]=X,this.byEnd[J.length]=X}addSourcemapLocation(J){this.sourcemapLocations.add(J)}append(J){if(typeof J!=="string")throw new TypeError("outro content must be a string");return this.outro+=J,this}appendLeft(J,Q){if(J=J+this.offset,typeof Q!=="string")throw new TypeError("inserted content must be a string");this._split(J);let X=this.byEnd[J];if(X)X.appendLeft(Q);else this.intro+=Q;return this}appendRight(J,Q){if(J=J+this.offset,typeof Q!=="string")throw new TypeError("inserted content must be a string");this._split(J);let X=this.byStart[J];if(X)X.appendRight(Q);else this.outro+=Q;return this}clone(){let J=new k(this.original,{filename:this.filename,offset:this.offset}),Q=this.firstChunk,X=J.firstChunk=J.lastSearchedChunk=Q.clone();while(Q){J.byStart[X.start]=X,J.byEnd[X.end]=X;let Z=Q.next,$=Z&&Z.clone();if($)X.next=$,$.previous=X,X=$;Q=Z}if(J.lastChunk=X,this.indentExclusionRanges)J.indentExclusionRanges=this.indentExclusionRanges.slice();return J.sourcemapLocations=new x(this.sourcemapLocations),J.intro=this.intro,J.outro=this.outro,J}generateDecodedMap(J){J=J||{};let Q=0,X=Object.keys(this.storedNames),Z=new r(J.hires),$=a(this.original);if(this.intro)Z.advance(this.intro);if(this.firstChunk.eachNext((Y)=>{let F=$(Y.start);if(Y.intro.length)Z.advance(Y.intro);if(Y.edited)Z.addEdit(Q,Y.content,F,Y.storeName?X.indexOf(Y.original):-1);else Z.addUneditedChunk(Q,Y,this.original,F,this.sourcemapLocations);if(Y.outro.length)Z.advance(Y.outro)}),this.outro)Z.advance(this.outro);return{file:J.file?J.file.split(/[/\\]/).pop():void 0,sources:[J.source?KJ(J.file||"",J.source):J.file||""],sourcesContent:J.includeContent?[this.original]:void 0,names:X,mappings:Z.raw,x_google_ignoreList:this.ignoreList?[Q]:void 0}}generateMap(J){return new s(this.generateDecodedMap(J))}_ensureindentStr(){if(this.indentStr===void 0)this.indentStr=WJ(this.original)}_getRawIndentString(){return this._ensureindentStr(),this.indentStr}getIndentString(){return this._ensureindentStr(),this.indentStr===null?"\t":this.indentStr}indent(J,Q){let X=/^[^\r\n]/gm;if(HJ(J))Q=J,J=void 0;if(J===void 0)this._ensureindentStr(),J=this.indentStr||"\t";if(J==="")return this;Q=Q||{};let Z={};if(Q.exclude)(typeof Q.exclude[0]==="number"?[Q.exclude]:Q.exclude).forEach((K)=>{for(let H=K[0];H<K[1];H+=1)Z[H]=!0});let $=Q.indentStart!==!1,Y=(W)=>{if($)return`${J}${W}`;return $=!0,W};this.intro=this.intro.replace(X,Y);let F=0,z=this.firstChunk;while(z){let W=z.end;if(z.edited){if(!Z[F]){if(z.content=z.content.replace(X,Y),z.content.length)$=z.content[z.content.length-1]===`
`}}else{F=z.start;while(F<W){if(!Z[F]){let K=this.original[F];if(K===`
`)$=!0;else if(K!=="\r"&&$)if($=!1,F===z.start)z.prependRight(J);else this._splitChunk(z,F),z=z.next,z.prependRight(J)}F+=1}}F=z.end,z=z.next}return this.outro=this.outro.replace(X,Y),this}insert(){throw new Error("magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)")}insertLeft(J,Q){if(!M.insertLeft)console.warn("magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead"),M.insertLeft=!0;return this.appendLeft(J,Q)}insertRight(J,Q){if(!M.insertRight)console.warn("magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead"),M.insertRight=!0;return this.prependRight(J,Q)}move(J,Q,X){if(J=J+this.offset,Q=Q+this.offset,X=X+this.offset,X>=J&&X<=Q)throw new Error("Cannot move a selection inside itself");this._split(J),this._split(Q),this._split(X);let Z=this.byStart[J],$=this.byEnd[Q],Y=Z.previous,F=$.next,z=this.byStart[X];if(!z&&$===this.lastChunk)return this;let W=z?z.previous:this.lastChunk;if(Y)Y.next=F;if(F)F.previous=Y;if(W)W.next=Z;if(z)z.previous=$;if(!Z.previous)this.firstChunk=$.next;if(!$.next)this.lastChunk=Z.previous,this.lastChunk.next=null;if(Z.previous=W,$.next=z||null,!W)this.firstChunk=Z;if(!z)this.lastChunk=$;return this}overwrite(J,Q,X,Z){return Z=Z||{},this.update(J,Q,X,{...Z,overwrite:!Z.contentOnly})}update(J,Q,X,Z){if(J=J+this.offset,Q=Q+this.offset,typeof X!=="string")throw new TypeError("replacement content must be a string");if(this.original.length!==0){while(J<0)J+=this.original.length;while(Q<0)Q+=this.original.length}if(Q>this.original.length)throw new Error("end is out of bounds");if(J===Q)throw new Error("Cannot overwrite a zero-length range – use appendLeft or prependRight instead");if(this._split(J),this._split(Q),Z===!0){if(!M.storeName)console.warn("The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string"),M.storeName=!0;Z={storeName:!0}}let $=Z!==void 0?Z.storeName:!1,Y=Z!==void 0?Z.overwrite:!1;if($){let W=this.original.slice(J,Q);Object.defineProperty(this.storedNames,W,{writable:!0,value:!0,enumerable:!0})}let F=this.byStart[J],z=this.byEnd[Q];if(F){let W=F;while(W!==z){if(W.next!==this.byStart[W.end])throw new Error("Cannot overwrite across a split point");W=W.next,W.edit("",!1)}F.edit(X,$,!Y)}else{let W=new b(J,Q,"").edit(X,$);z.next=W,W.previous=z}return this}prepend(J){if(typeof J!=="string")throw new TypeError("outro content must be a string");return this.intro=J+this.intro,this}prependLeft(J,Q){if(J=J+this.offset,typeof Q!=="string")throw new TypeError("inserted content must be a string");this._split(J);let X=this.byEnd[J];if(X)X.prependLeft(Q);else this.intro=Q+this.intro;return this}prependRight(J,Q){if(J=J+this.offset,typeof Q!=="string")throw new TypeError("inserted content must be a string");this._split(J);let X=this.byStart[J];if(X)X.prependRight(Q);else this.outro=Q+this.outro;return this}remove(J,Q){if(J=J+this.offset,Q=Q+this.offset,this.original.length!==0){while(J<0)J+=this.original.length;while(Q<0)Q+=this.original.length}if(J===Q)return this;if(J<0||Q>this.original.length)throw new Error("Character is out of bounds");if(J>Q)throw new Error("end must be greater than start");this._split(J),this._split(Q);let X=this.byStart[J];while(X)X.intro="",X.outro="",X.edit(""),X=Q>X.end?this.byStart[X.end]:null;return this}reset(J,Q){if(J=J+this.offset,Q=Q+this.offset,this.original.length!==0){while(J<0)J+=this.original.length;while(Q<0)Q+=this.original.length}if(J===Q)return this;if(J<0||Q>this.original.length)throw new Error("Character is out of bounds");if(J>Q)throw new Error("end must be greater than start");this._split(J),this._split(Q);let X=this.byStart[J];while(X)X.reset(),X=Q>X.end?this.byStart[X.end]:null;return this}lastChar(){if(this.outro.length)return this.outro[this.outro.length-1];let J=this.lastChunk;do{if(J.outro.length)return J.outro[J.outro.length-1];if(J.content.length)return J.content[J.content.length-1];if(J.intro.length)return J.intro[J.intro.length-1]}while(J=J.previous);if(this.intro.length)return this.intro[this.intro.length-1];return""}lastLine(){let J=this.outro.lastIndexOf(L);if(J!==-1)return this.outro.substr(J+1);let Q=this.outro,X=this.lastChunk;do{if(X.outro.length>0){if(J=X.outro.lastIndexOf(L),J!==-1)return X.outro.substr(J+1)+Q;Q=X.outro+Q}if(X.content.length>0){if(J=X.content.lastIndexOf(L),J!==-1)return X.content.substr(J+1)+Q;Q=X.content+Q}if(X.intro.length>0){if(J=X.intro.lastIndexOf(L),J!==-1)return X.intro.substr(J+1)+Q;Q=X.intro+Q}}while(X=X.previous);if(J=this.intro.lastIndexOf(L),J!==-1)return this.intro.substr(J+1)+Q;return this.intro+Q}slice(J=0,Q=this.original.length-this.offset){if(J=J+this.offset,Q=Q+this.offset,this.original.length!==0){while(J<0)J+=this.original.length;while(Q<0)Q+=this.original.length}let X="",Z=this.firstChunk;while(Z&&(Z.start>J||Z.end<=J)){if(Z.start<Q&&Z.end>=Q)return X;Z=Z.next}if(Z&&Z.edited&&Z.start!==J)throw new Error(`Cannot use replaced character ${J} as slice start anchor.`);let $=Z;while(Z){if(Z.intro&&($!==Z||Z.start===J))X+=Z.intro;let Y=Z.start<Q&&Z.end>=Q;if(Y&&Z.edited&&Z.end!==Q)throw new Error(`Cannot use replaced character ${Q} as slice end anchor.`);let F=$===Z?J-Z.start:0,z=Y?Z.content.length+Q-Z.end:Z.content.length;if(X+=Z.content.slice(F,z),Z.outro&&(!Y||Z.end===Q))X+=Z.outro;if(Y)break;Z=Z.next}return X}snip(J,Q){let X=this.clone();return X.remove(0,J),X.remove(Q,X.original.length),X}_split(J){if(this.byStart[J]||this.byEnd[J])return;let Q=this.lastSearchedChunk,X=Q,Z=J>Q.end;while(Q){if(Q.contains(J))return this._splitChunk(Q,J);if(Q=Z?this.byStart[Q.end]:this.byEnd[Q.start],Q===X)return;X=Q}}_splitChunk(J,Q){if(J.edited&&J.content.length){let Z=a(this.original)(Q);throw new Error(`Cannot split a chunk that has already been edited (${Z.line}:${Z.column} – "${J.original}")`)}let X=J.split(Q);if(this.byEnd[Q]=J,this.byStart[Q]=X,this.byEnd[X.end]=X,J===this.lastChunk)this.lastChunk=X;return this.lastSearchedChunk=J,!0}toString(){let J=this.intro,Q=this.firstChunk;while(Q)J+=Q.toString(),Q=Q.next;return J+this.outro}isEmpty(){let J=this.firstChunk;do if(J.intro.length&&J.intro.trim()||J.content.length&&J.content.trim()||J.outro.length&&J.outro.trim())return!1;while(J=J.next);return!0}length(){let J=this.firstChunk,Q=0;do Q+=J.intro.length+J.content.length+J.outro.length;while(J=J.next);return Q}trimLines(){return this.trim("[\\r\\n]")}trim(J){return this.trimStart(J).trimEnd(J)}trimEndAborted(J){let Q=new RegExp((J||"\\s")+"+$");if(this.outro=this.outro.replace(Q,""),this.outro.length)return!0;let X=this.lastChunk;do{let Z=X.end,$=X.trimEnd(Q);if(X.end!==Z){if(this.lastChunk===X)this.lastChunk=X.next;this.byEnd[X.end]=X,this.byStart[X.next.start]=X.next,this.byEnd[X.next.end]=X.next}if($)return!0;X=X.previous}while(X);return!1}trimEnd(J){return this.trimEndAborted(J),this}trimStartAborted(J){let Q=new RegExp("^"+(J||"\\s")+"+");if(this.intro=this.intro.replace(Q,""),this.intro.length)return!0;let X=this.firstChunk;do{let Z=X.end,$=X.trimStart(Q);if(X.end!==Z){if(X===this.lastChunk)this.lastChunk=X.next;this.byEnd[X.end]=X,this.byStart[X.next.start]=X.next,this.byEnd[X.next.end]=X.next}if($)return!0;X=X.next}while(X);return!1}trimStart(J){return this.trimStartAborted(J),this}hasChanged(){return this.original!==this.toString()}_replaceRegexp(J,Q){function X($,Y){if(typeof Q==="string")return Q.replace(/\$(\$|&|\d+)/g,(F,z)=>{if(z==="$")return"$";if(z==="&")return $[0];if(+z<$.length)return $[+z];return`$${z}`});else return Q(...$,$.index,Y,$.groups)}function Z($,Y){let F,z=[];while(F=$.exec(Y))z.push(F);return z}if(J.global)Z(J,this.original).forEach((Y)=>{if(Y.index!=null){let F=X(Y,this.original);if(F!==Y[0])this.overwrite(Y.index,Y.index+Y[0].length,F)}});else{let $=this.original.match(J);if($&&$.index!=null){let Y=X($,this.original);if(Y!==$[0])this.overwrite($.index,$.index+$[0].length,Y)}}return this}_replaceString(J,Q){let{original:X}=this,Z=X.indexOf(J);if(Z!==-1){if(typeof Q==="function")Q=Q(J,Z,X);if(J!==Q)this.overwrite(Z,Z+J.length,Q)}return this}replace(J,Q){if(typeof J==="string")return this._replaceString(J,Q);return this._replaceRegexp(J,Q)}_replaceAllString(J,Q){let{original:X}=this,Z=J.length;for(let $=X.indexOf(J);$!==-1;$=X.indexOf(J,$+Z)){let Y=X.slice($,$+Z),F=Q;if(typeof Q==="function")F=Q(Y,$,X);if(Y!==F)this.overwrite($,$+Z,F)}return this}replaceAll(J,Q){if(typeof J==="string")return this._replaceAllString(J,Q);if(!J.global)throw new TypeError("MagicString.prototype.replaceAll called with a non-global RegExp argument");return this._replaceRegexp(J,Q)}}function f(J=""){let Q=J.length,X=Q^Q,Z=0,$;while(Q>=4)$=J.charCodeAt(Z)&255|(J.charCodeAt(++Z)&255)<<8|(J.charCodeAt(++Z)&255)<<16|(J.charCodeAt(++Z)&255)<<24,$=($&65535)*1540483477+((($>>>16)*1540483477&65535)<<16),$^=$>>>24,$=($&65535)*1540483477+((($>>>16)*1540483477&65535)<<16),X=(X&65535)*1540483477+(((X>>>16)*1540483477&65535)<<16)^$,Q-=4,++Z;if(Q>=3)X^=(J.charCodeAt(Z+2)&255)<<16;if(Q>=2)X^=(J.charCodeAt(Z+1)&255)<<8;if(Q>=1)X^=J.charCodeAt(Z)&255,X=(X&65535)*1540483477+(((X>>>16)*1540483477&65535)<<16);return X^=X>>>13,X=(X&65535)*1540483477+(((X>>>16)*1540483477&65535)<<16),X^=X>>>15,(X>>>0).toString(36)}function h(J){return/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(J)}function E(J){return JSON.stringify(J)}function GJ(J={}){let{classPrefix:Q="ss",debug:X}=J,Z=X??process.env.DEBUG_STYLED_STATIC==="true",$=new Map,Y,F=!1;return{name:"styled-static",enforce:"post",configResolved(z){Y=z,F=Y.command==="serve"},resolveId(z){if(z.startsWith("\x00styled-static:"))return z;if(z.startsWith("styled-static:"))return"\x00"+z;return null},load(z){if(z.startsWith("\x00styled-static:")){let W=z.slice(15);return $.get(W)??""}return null},handleHotUpdate({file:z,server:W}){if(/\.[tj]sx?$/.test(z)){let K=f(t(z)).slice(0,8);for(let[H]of $)if(H.startsWith(K)){let A=W.moduleGraph.getModuleById(`\x00styled-static:${H}`);if(A)W.moduleGraph.invalidateModule(A)}}},async transform(z,W){if(!/\.[cm]?[jt]sx?$/.test(W)||/node_modules/.test(W))return null;let K=z.includes("styled-static"),H=z.includes('from "./index"')||z.includes("from './index'")||z.includes('from "../index"')||z.includes("from '../index'");if(!K&&!H)return null;if(Z)console.log("[styled-static] Transforming:",W);let A;try{if(A=this.parse(z),Z)console.log("[styled-static] AST parsed successfully, body length:",A.body.length)}catch(q){if(Z)console.log("[styled-static] AST parse error:",q);return null}let G=UJ(A);if(Z)console.log("[styled-static] Found imports:",G);let U=G.css||G.styled||G.createGlobalStyle||G.keyframes,P=G.styledVariants||G.cssVariants,R=!!G.withComponent;if(!U&&!P&&!R){if(Z)console.log("[styled-static] No imports found, skipping");return null}let _=U?_J(A,G,z):[];if(Z)console.log("[styled-static] Found templates:",_.length);let T=P?BJ(A,z,G):[];if(Z)console.log("[styled-static] Found variant calls:",T.length);let B=R?RJ(A,G):[];if(Z)console.log("[styled-static] Found withComponent calls:",B.length);if(_.length===0&&T.length===0&&B.length===0){if(Z)console.log("[styled-static] No templates, variants, or withComponent found, skipping");return null}let j=new k(z),p=f(t(W)).slice(0,8),w=[],S=!1,l=0;for(let q=0;q<_.length;q++){let O=_[q];if(!O)continue;let D=OJ(z,O.node.quasi),V=F?6:8,v=f(D).slice(0,V),I=`${Q}-${v}`,g=O.type==="createGlobalStyle"?D:`.${I} { ${D} }`,C=`${p}-${l++}.css`;$.set(C,g),w.push(`import "styled-static:${C}";`);let m=DJ(O,I,F);if(j.overwrite(O.node.start,O.node.end,m),O.type==="styled"||O.type==="styledExtend"||O.type==="styledAttrs")S=!0}for(let q of T){let O=f(q.baseCss||"").slice(0,6),D=`${Q}-${O}`,V="";if(q.baseCss)V+=`.${D} { ${q.baseCss} }
`;for(let[C,m]of q.variants)for(let[e,JJ]of m){let QJ=`${D}--${C}-${e}`;V+=`.${QJ} { ${JJ} }
`}let v=`${p}-${l++}.css`;$.set(v,V),w.push(`import "styled-static:${v}";`);let I=Array.from(q.variants.keys()),g=PJ(q,D,I,F);if(j.overwrite(q.start,q.end,g),q.type==="styledVariants")S=!0}for(let q of B){if(!h(q.fromComponent))throw new Error(`[styled-static] Invalid fromComponent name: ${q.fromComponent}`);let O=/^[a-z]/.test(q.toComponent),D;if(O)D=`Object.assign((p) => createElement(${E(q.toComponent)}, {...p, className: m(${q.fromComponent}.className, p.className)}), { className: ${q.fromComponent}.className })`;else{if(!h(q.toComponent))throw new Error(`[styled-static] Invalid toComponent name: ${q.toComponent}`);D=`Object.assign((p) => createElement(${q.toComponent}, {...p, className: m(${q.fromComponent}.className, p.className)}), { className: ${q.fromComponent}.className })`}j.overwrite(q.start,q.end,D),S=!0}let n=G.source==="./index"||G.source==="../index"?G.source.replace("/index","/runtime"):"styled-static/runtime",N="";if(w.length>0)N+=w.join(`
`)+`
`;if(S)N+=`import { createElement } from "react";
`,N+=`import { m } from "${n}";
`;if(N)j.prepend(N+`
`);return{code:j.toString(),map:j.generateMap({hires:!0})}}}}function UJ(J){let Q={};for(let X of J.body)if(X.type==="ImportDeclaration"){let Z=X.source.value;if(Z==="styled-static"||Z==="./index"||Z==="../index"){Q.source=Z;for(let Y of X.specifiers)if(Y.type==="ImportSpecifier"){let F=Y.imported.name,z=Y.local.name;if(F==="styled")Q.styled=z;if(F==="css")Q.css=z;if(F==="createGlobalStyle")Q.createGlobalStyle=z;if(F==="keyframes")Q.keyframes=z;if(F==="styledVariants")Q.styledVariants=z;if(F==="cssVariants")Q.cssVariants=z;if(F==="withComponent")Q.withComponent=z}}}return Q}function _J(J,Q,X){let Z=[];function $(Y){for(let F of Y.declarations)if(F.init?.type==="TaggedTemplateExpression"&&F.id.type==="Identifier"){let z=F.init,W=F.id.name,K=jJ(z,Q,W,X);if(K)Z.push(K)}}for(let Y of J.body){if(Y.type==="VariableDeclaration")$(Y);if(Y.type==="ExportNamedDeclaration"&&Y.declaration?.type==="VariableDeclaration")$(Y.declaration)}return Z}function jJ(J,Q,X,Z){let{tag:$}=J;if($.type==="MemberExpression"&&$.object.type==="Identifier"&&$.object.name===Q.styled&&$.property.type==="Identifier")return{type:"styled",node:J,tag:$.property.name,variableName:X};if($.type==="CallExpression"&&$.callee.type==="Identifier"&&$.callee.name===Q.styled&&$.arguments[0]?.type==="Identifier")return{type:"styledExtend",node:J,tag:"",baseComponent:$.arguments[0].name,variableName:X};if($.type==="Identifier"&&$.name===Q.css)return{type:"css",node:J,tag:"",variableName:X};if($.type==="Identifier"&&$.name===Q.createGlobalStyle)return{type:"createGlobalStyle",node:J,tag:"",variableName:X};if($.type==="Identifier"&&$.name===Q.keyframes)return{type:"keyframes",node:J,tag:"",variableName:X};if($.type==="CallExpression"&&$.callee.type==="MemberExpression"&&$.callee.property.type==="Identifier"&&$.callee.property.name==="attrs"&&$.callee.object.type==="MemberExpression"&&$.callee.object.object.type==="Identifier"&&$.callee.object.object.name===Q.styled&&$.callee.object.property.type==="Identifier"&&$.arguments.length===1){let Y=$.callee.object.property.name,F=$.arguments[0],z=Z.slice(F.start,F.end);return{type:"styledAttrs",node:J,tag:Y,variableName:X,attrsArg:z}}return null}function OJ(J,Q){return J.slice(Q.start+1,Q.end-1)}function DJ(J,Q,X){let Z=E(Q);switch(J.type){case"styled":return`Object.assign((p) => createElement(${E(J.tag)}, {...p, className: m(${Z}, p.className)}), { className: ${Z} })`;case"styledExtend":return`Object.assign((p) => createElement(${J.baseComponent}, {...p, className: m(${Z}, p.className)}), { className: ${J.baseComponent}.className + " " + ${Z} })`;case"styledAttrs":return`Object.assign((p) => createElement(${E(J.tag)}, {...(${J.attrsArg??"{}"}), ...p, className: m(${Z}, p.className)}), { className: ${Z} })`;case"css":return Z;case"keyframes":return Z;case"createGlobalStyle":return"() => null"}}function t(J){return J.replace(/\\/g,"/").toLowerCase()}function BJ(J,Q,X){let Z=[];function $(Y){for(let F of Y.declarations)if(F.init?.type==="CallExpression"&&F.id.type==="Identifier"){let z=F.init,W=F.id.name,K=EJ(z,Q,X,W);if(K)Z.push(K)}}for(let Y of J.body){if(Y.type==="VariableDeclaration")$(Y);if(Y.type==="ExportNamedDeclaration"&&Y.declaration?.type==="VariableDeclaration")$(Y.declaration)}return Z}function EJ(J,Q,X,Z){if(J.callee.type!=="Identifier")return null;let $=J.callee.name,Y=$===X.styledVariants,F=$===X.cssVariants;if(!Y&&!F)return null;if(J.arguments.length!==1||J.arguments[0]?.type!=="ObjectExpression")return null;let z=J.arguments[0],W,K,H=new Map;for(let A of z.properties){if(A.type!=="Property"||A.key.type!=="Identifier")continue;let G=A.key.name;if(G==="component"){if(A.value.type==="Literal"&&typeof A.value.value==="string")W=A.value.value;else if(A.value.type==="Identifier")W=A.value.name}if(G==="css"){if(A.value.type==="Literal"&&typeof A.value.value==="string")K=A.value.value;else if(A.value.type==="TemplateLiteral"){let U=A.value;K=Q.slice(U.start+1,U.end-1)}else if(A.value.type==="TaggedTemplateExpression"){let U=A.value;if(U.tag.type==="Identifier"&&U.tag.name===X.css)K=Q.slice(U.quasi.start+1,U.quasi.end-1)}}if(G==="variants"&&A.value.type==="ObjectExpression")for(let U of A.value.properties){if(U.type!=="Property"||U.key.type!=="Identifier")continue;if(U.value.type!=="ObjectExpression")continue;let P=U.key.name,R=new Map;for(let _ of U.value.properties){if(_.type!=="Property"||_.key.type!=="Identifier")continue;let T=_.key.name,B;if(_.value.type==="Literal"&&typeof _.value.value==="string")B=_.value.value;else if(_.value.type==="TemplateLiteral"){let j=_.value;B=Q.slice(j.start+1,j.end-1)}else if(_.value.type==="TaggedTemplateExpression"){let j=_.value;if(j.tag.type==="Identifier"&&j.tag.name===X.css)B=Q.slice(j.quasi.start+1,j.quasi.end-1)}if(B)R.set(T,B)}if(R.size>0)H.set(P,R)}}return{type:Y?"styledVariants":"cssVariants",start:J.start,end:J.end,component:W,baseCss:K,variants:H,variableName:Z}}function PJ(J,Q,X,Z){let $=E(Q),Y=J.type==="cssVariants",F=[];for(let K of X){let H=J.variants.get(K);if(H){let A=Y?`variants.${K}`:K,G=Array.from(H.keys()).map((U,P)=>`${P===0?"if":"else if"} (${A} === ${E(U)}) c += ${E(` ${Q}--${K}-${U}`)}`).join("; ");if(G)F.push(G)}}let z=F.length>0?F.join("; ")+"; ":"",W=X.length>0?`{ ${X.join(", ")}, className, ...p }`:"{ className, ...p }";if(J.type==="styledVariants")if(J.component&&/^[a-z]/.test(J.component)){if(!J.component||!/^[a-z][a-z0-9]*$/.test(J.component))throw new Error(`[styled-static] Invalid HTML tag name: ${J.component}`);let H=E(J.component);return`Object.assign((${W}) => { let c = ${$}; ${z}return createElement(${H}, {...p, className: m(c, className)}); }, { className: ${$} })`}else{if(!J.component||!h(J.component))throw new Error(`[styled-static] Invalid component name: ${J.component}`);return`Object.assign((${W}) => { let c = ${$}; ${z}return createElement(${J.component}, {...p, className: m(c, className)}); }, { className: ${J.component}.className + " " + ${$} })`}return`(variants) => { let c = ${$}; ${z}return c; }`}function RJ(J,Q){let X=[];function Z($){for(let Y of $.declarations)if(Y.init?.type==="CallExpression"&&Y.id.type==="Identifier"){let F=Y.init,z=Y.id.name;if(F.callee.type==="Identifier"&&F.callee.name===Q.withComponent&&F.arguments.length===2){let W=F.arguments[0],K=F.arguments[1],H,A;if(W?.type==="Literal"&&typeof W.value==="string")H=W.value;else if(W?.type==="Identifier")H=W.name;if(K?.type==="Identifier")A=K.name;if(H&&A)X.push({start:F.start,end:F.end,toComponent:H,fromComponent:A,variableName:z})}}}for(let $ of J.body){if($.type==="VariableDeclaration")Z($);if($.type==="ExportNamedDeclaration"&&$.declaration?.type==="VariableDeclaration")Z($.declaration)}return X}var wJ=GJ;export{GJ as styledStatic,wJ as default};
