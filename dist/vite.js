var $J=44,YJ=59,o="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",s=new Uint8Array(64),zJ=new Uint8Array(128);for(let J=0;J<o.length;J++){let Q=o.charCodeAt(J);s[J]=Q,zJ[Q]=J}function w(J,Q,X){let Z=Q-X;Z=Z<0?-Z<<1|1:Z<<1;do{let $=Z&31;if(Z>>>=5,Z>0)$|=32;J.write(s[$])}while(Z>0);return Q}var i=16384,a=typeof TextDecoder!=="undefined"?new TextDecoder:typeof Buffer!=="undefined"?{decode(J){return Buffer.from(J.buffer,J.byteOffset,J.byteLength).toString()}}:{decode(J){let Q="";for(let X=0;X<J.length;X++)Q+=String.fromCharCode(J[X]);return Q}},FJ=class{constructor(){this.pos=0,this.out="",this.buffer=new Uint8Array(i)}write(J){let{buffer:Q}=this;if(Q[this.pos++]=J,this.pos===i)this.out+=a.decode(Q),this.pos=0}flush(){let{buffer:J,out:Q,pos:X}=this;return X>0?Q+a.decode(J.subarray(0,X)):Q}};function r(J){let Q=new FJ,X=0,Z=0,$=0,Y=0;for(let F=0;F<J.length;F++){let z=J[F];if(F>0)Q.write(YJ);if(z.length===0)continue;let W=0;for(let q=0;q<z.length;q++){let A=z[q];if(q>0)Q.write($J);if(W=w(Q,A[0],W),A.length===1)continue;if(X=w(Q,A[1],X),Z=w(Q,A[2],Z),$=w(Q,A[3],$),A.length===4)continue;Y=w(Q,A[4],Y)}}return Q.flush()}class g{constructor(J){this.bits=J instanceof g?J.bits.slice():[]}add(J){this.bits[J>>5]|=1<<(J&31)}has(J){return!!(this.bits[J>>5]&1<<(J&31))}}class S{constructor(J,Q,X){this.start=J,this.end=Q,this.original=X,this.intro="",this.outro="",this.content=X,this.storeName=!1,this.edited=!1,this.previous=null,this.next=null}appendLeft(J){this.outro+=J}appendRight(J){this.intro=this.intro+J}clone(){let J=new S(this.start,this.end,this.original);return J.intro=this.intro,J.outro=this.outro,J.content=this.content,J.storeName=this.storeName,J.edited=this.edited,J}contains(J){return this.start<J&&J<this.end}eachNext(J){let Q=this;while(Q)J(Q),Q=Q.next}eachPrevious(J){let Q=this;while(Q)J(Q),Q=Q.previous}edit(J,Q,X){if(this.content=J,!X)this.intro="",this.outro="";return this.storeName=Q,this.edited=!0,this}prependLeft(J){this.outro=J+this.outro}prependRight(J){this.intro=J+this.intro}reset(){if(this.intro="",this.outro="",this.edited)this.content=this.original,this.storeName=!1,this.edited=!1}split(J){let Q=J-this.start,X=this.original.slice(0,Q),Z=this.original.slice(Q);this.original=X;let $=new S(J,this.end,Z);if($.outro=this.outro,this.outro="",this.end=J,this.edited)$.edit("",!1),this.content="";else this.content=X;if($.next=this.next,$.next)$.next.previous=$;return $.previous=this,this.next=$,$}toString(){return this.intro+this.content+this.outro}trimEnd(J){if(this.outro=this.outro.replace(J,""),this.outro.length)return!0;let Q=this.content.replace(J,"");if(Q.length){if(Q!==this.content){if(this.split(this.start+Q.length).edit("",void 0,!0),this.edited)this.edit(Q,this.storeName,!0)}return!0}else if(this.edit("",void 0,!0),this.intro=this.intro.replace(J,""),this.intro.length)return!0}trimStart(J){if(this.intro=this.intro.replace(J,""),this.intro.length)return!0;let Q=this.content.replace(J,"");if(Q.length){if(Q!==this.content){let X=this.split(this.end-Q.length);if(this.edited)X.edit(Q,this.storeName,!0);this.edit("",void 0,!0)}return!0}else if(this.edit("",void 0,!0),this.outro=this.outro.replace(J,""),this.outro.length)return!0}}function WJ(){if(typeof globalThis!=="undefined"&&typeof globalThis.btoa==="function")return(J)=>globalThis.btoa(unescape(encodeURIComponent(J)));else if(typeof Buffer==="function")return(J)=>Buffer.from(J,"utf-8").toString("base64");else return()=>{throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.")}}var HJ=WJ();class n{constructor(J){if(this.version=3,this.file=J.file,this.sources=J.sources,this.sourcesContent=J.sourcesContent,this.names=J.names,this.mappings=r(J.mappings),typeof J.x_google_ignoreList!=="undefined")this.x_google_ignoreList=J.x_google_ignoreList;if(typeof J.debugId!=="undefined")this.debugId=J.debugId}toString(){return JSON.stringify(this)}toUrl(){return"data:application/json;charset=utf-8;base64,"+HJ(this.toString())}}function qJ(J){let Q=J.split(`
`),X=Q.filter((Y)=>/^\t+/.test(Y)),Z=Q.filter((Y)=>/^ {2,}/.test(Y));if(X.length===0&&Z.length===0)return null;if(X.length>=Z.length)return"\t";let $=Z.reduce((Y,F)=>{let z=/^ +/.exec(F)[0].length;return Math.min(z,Y)},1/0);return new Array($+1).join(" ")}function AJ(J,Q){let X=J.split(/[/\\]/),Z=Q.split(/[/\\]/);X.pop();while(X[0]===Z[0])X.shift(),Z.shift();if(X.length){let $=X.length;while($--)X[$]=".."}return X.concat(Z).join("/")}var GJ=Object.prototype.toString;function UJ(J){return GJ.call(J)==="[object Object]"}function t(J){let Q=J.split(`
`),X=[];for(let Z=0,$=0;Z<Q.length;Z++)X.push($),$+=Q[Z].length+1;return function Z($){let Y=0,F=X.length;while(Y<F){let q=Y+F>>1;if($<X[q])F=q;else Y=q+1}let z=Y-1,W=$-X[z];return{line:z,column:W}}}var KJ=/\w/;class e{constructor(J){this.hires=J,this.generatedCodeLine=0,this.generatedCodeColumn=0,this.raw=[],this.rawSegments=this.raw[this.generatedCodeLine]=[],this.pending=null}addEdit(J,Q,X,Z){if(Q.length){let $=Q.length-1,Y=Q.indexOf(`
`,0),F=-1;while(Y>=0&&$>Y){let W=[this.generatedCodeColumn,J,X.line,X.column];if(Z>=0)W.push(Z);this.rawSegments.push(W),this.generatedCodeLine+=1,this.raw[this.generatedCodeLine]=this.rawSegments=[],this.generatedCodeColumn=0,F=Y,Y=Q.indexOf(`
`,Y+1)}let z=[this.generatedCodeColumn,J,X.line,X.column];if(Z>=0)z.push(Z);this.rawSegments.push(z),this.advance(Q.slice(F+1))}else if(this.pending)this.rawSegments.push(this.pending),this.advance(Q);this.pending=null}addUneditedChunk(J,Q,X,Z,$){let Y=Q.start,F=!0,z=!1;while(Y<Q.end){if(X[Y]===`
`)Z.line+=1,Z.column=0,this.generatedCodeLine+=1,this.raw[this.generatedCodeLine]=this.rawSegments=[],this.generatedCodeColumn=0,F=!0,z=!1;else{if(this.hires||F||$.has(Y)){let W=[this.generatedCodeColumn,J,Z.line,Z.column];if(this.hires==="boundary")if(KJ.test(X[Y])){if(!z)this.rawSegments.push(W),z=!0}else this.rawSegments.push(W),z=!1;else this.rawSegments.push(W)}Z.column+=1,this.generatedCodeColumn+=1,F=!1}Y+=1}this.pending=null}advance(J){if(!J)return;let Q=J.split(`
`);if(Q.length>1){for(let X=0;X<Q.length-1;X++)this.generatedCodeLine++,this.raw[this.generatedCodeLine]=this.rawSegments=[];this.generatedCodeColumn=0}this.generatedCodeColumn+=Q[Q.length-1].length}}var f=`
`,y={insertLeft:!1,insertRight:!1,storeName:!1};class m{constructor(J,Q={}){let X=new S(0,J.length,J);Object.defineProperties(this,{original:{writable:!0,value:J},outro:{writable:!0,value:""},intro:{writable:!0,value:""},firstChunk:{writable:!0,value:X},lastChunk:{writable:!0,value:X},lastSearchedChunk:{writable:!0,value:X},byStart:{writable:!0,value:{}},byEnd:{writable:!0,value:{}},filename:{writable:!0,value:Q.filename},indentExclusionRanges:{writable:!0,value:Q.indentExclusionRanges},sourcemapLocations:{writable:!0,value:new g},storedNames:{writable:!0,value:{}},indentStr:{writable:!0,value:void 0},ignoreList:{writable:!0,value:Q.ignoreList},offset:{writable:!0,value:Q.offset||0}}),this.byStart[0]=X,this.byEnd[J.length]=X}addSourcemapLocation(J){this.sourcemapLocations.add(J)}append(J){if(typeof J!=="string")throw new TypeError("outro content must be a string");return this.outro+=J,this}appendLeft(J,Q){if(J=J+this.offset,typeof Q!=="string")throw new TypeError("inserted content must be a string");this._split(J);let X=this.byEnd[J];if(X)X.appendLeft(Q);else this.intro+=Q;return this}appendRight(J,Q){if(J=J+this.offset,typeof Q!=="string")throw new TypeError("inserted content must be a string");this._split(J);let X=this.byStart[J];if(X)X.appendRight(Q);else this.outro+=Q;return this}clone(){let J=new m(this.original,{filename:this.filename,offset:this.offset}),Q=this.firstChunk,X=J.firstChunk=J.lastSearchedChunk=Q.clone();while(Q){J.byStart[X.start]=X,J.byEnd[X.end]=X;let Z=Q.next,$=Z&&Z.clone();if($)X.next=$,$.previous=X,X=$;Q=Z}if(J.lastChunk=X,this.indentExclusionRanges)J.indentExclusionRanges=this.indentExclusionRanges.slice();return J.sourcemapLocations=new g(this.sourcemapLocations),J.intro=this.intro,J.outro=this.outro,J}generateDecodedMap(J){J=J||{};let Q=0,X=Object.keys(this.storedNames),Z=new e(J.hires),$=t(this.original);if(this.intro)Z.advance(this.intro);if(this.firstChunk.eachNext((Y)=>{let F=$(Y.start);if(Y.intro.length)Z.advance(Y.intro);if(Y.edited)Z.addEdit(Q,Y.content,F,Y.storeName?X.indexOf(Y.original):-1);else Z.addUneditedChunk(Q,Y,this.original,F,this.sourcemapLocations);if(Y.outro.length)Z.advance(Y.outro)}),this.outro)Z.advance(this.outro);return{file:J.file?J.file.split(/[/\\]/).pop():void 0,sources:[J.source?AJ(J.file||"",J.source):J.file||""],sourcesContent:J.includeContent?[this.original]:void 0,names:X,mappings:Z.raw,x_google_ignoreList:this.ignoreList?[Q]:void 0}}generateMap(J){return new n(this.generateDecodedMap(J))}_ensureindentStr(){if(this.indentStr===void 0)this.indentStr=qJ(this.original)}_getRawIndentString(){return this._ensureindentStr(),this.indentStr}getIndentString(){return this._ensureindentStr(),this.indentStr===null?"\t":this.indentStr}indent(J,Q){let X=/^[^\r\n]/gm;if(UJ(J))Q=J,J=void 0;if(J===void 0)this._ensureindentStr(),J=this.indentStr||"\t";if(J==="")return this;Q=Q||{};let Z={};if(Q.exclude)(typeof Q.exclude[0]==="number"?[Q.exclude]:Q.exclude).forEach((q)=>{for(let A=q[0];A<q[1];A+=1)Z[A]=!0});let $=Q.indentStart!==!1,Y=(W)=>{if($)return`${J}${W}`;return $=!0,W};this.intro=this.intro.replace(X,Y);let F=0,z=this.firstChunk;while(z){let W=z.end;if(z.edited){if(!Z[F]){if(z.content=z.content.replace(X,Y),z.content.length)$=z.content[z.content.length-1]===`
`}}else{F=z.start;while(F<W){if(!Z[F]){let q=this.original[F];if(q===`
`)$=!0;else if(q!=="\r"&&$)if($=!1,F===z.start)z.prependRight(J);else this._splitChunk(z,F),z=z.next,z.prependRight(J)}F+=1}}F=z.end,z=z.next}return this.outro=this.outro.replace(X,Y),this}insert(){throw new Error("magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)")}insertLeft(J,Q){if(!y.insertLeft)console.warn("magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead"),y.insertLeft=!0;return this.appendLeft(J,Q)}insertRight(J,Q){if(!y.insertRight)console.warn("magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead"),y.insertRight=!0;return this.prependRight(J,Q)}move(J,Q,X){if(J=J+this.offset,Q=Q+this.offset,X=X+this.offset,X>=J&&X<=Q)throw new Error("Cannot move a selection inside itself");this._split(J),this._split(Q),this._split(X);let Z=this.byStart[J],$=this.byEnd[Q],Y=Z.previous,F=$.next,z=this.byStart[X];if(!z&&$===this.lastChunk)return this;let W=z?z.previous:this.lastChunk;if(Y)Y.next=F;if(F)F.previous=Y;if(W)W.next=Z;if(z)z.previous=$;if(!Z.previous)this.firstChunk=$.next;if(!$.next)this.lastChunk=Z.previous,this.lastChunk.next=null;if(Z.previous=W,$.next=z||null,!W)this.firstChunk=Z;if(!z)this.lastChunk=$;return this}overwrite(J,Q,X,Z){return Z=Z||{},this.update(J,Q,X,{...Z,overwrite:!Z.contentOnly})}update(J,Q,X,Z){if(J=J+this.offset,Q=Q+this.offset,typeof X!=="string")throw new TypeError("replacement content must be a string");if(this.original.length!==0){while(J<0)J+=this.original.length;while(Q<0)Q+=this.original.length}if(Q>this.original.length)throw new Error("end is out of bounds");if(J===Q)throw new Error("Cannot overwrite a zero-length range – use appendLeft or prependRight instead");if(this._split(J),this._split(Q),Z===!0){if(!y.storeName)console.warn("The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string"),y.storeName=!0;Z={storeName:!0}}let $=Z!==void 0?Z.storeName:!1,Y=Z!==void 0?Z.overwrite:!1;if($){let W=this.original.slice(J,Q);Object.defineProperty(this.storedNames,W,{writable:!0,value:!0,enumerable:!0})}let F=this.byStart[J],z=this.byEnd[Q];if(F){let W=F;while(W!==z){if(W.next!==this.byStart[W.end])throw new Error("Cannot overwrite across a split point");W=W.next,W.edit("",!1)}F.edit(X,$,!Y)}else{let W=new S(J,Q,"").edit(X,$);z.next=W,W.previous=z}return this}prepend(J){if(typeof J!=="string")throw new TypeError("outro content must be a string");return this.intro=J+this.intro,this}prependLeft(J,Q){if(J=J+this.offset,typeof Q!=="string")throw new TypeError("inserted content must be a string");this._split(J);let X=this.byEnd[J];if(X)X.prependLeft(Q);else this.intro=Q+this.intro;return this}prependRight(J,Q){if(J=J+this.offset,typeof Q!=="string")throw new TypeError("inserted content must be a string");this._split(J);let X=this.byStart[J];if(X)X.prependRight(Q);else this.outro=Q+this.outro;return this}remove(J,Q){if(J=J+this.offset,Q=Q+this.offset,this.original.length!==0){while(J<0)J+=this.original.length;while(Q<0)Q+=this.original.length}if(J===Q)return this;if(J<0||Q>this.original.length)throw new Error("Character is out of bounds");if(J>Q)throw new Error("end must be greater than start");this._split(J),this._split(Q);let X=this.byStart[J];while(X)X.intro="",X.outro="",X.edit(""),X=Q>X.end?this.byStart[X.end]:null;return this}reset(J,Q){if(J=J+this.offset,Q=Q+this.offset,this.original.length!==0){while(J<0)J+=this.original.length;while(Q<0)Q+=this.original.length}if(J===Q)return this;if(J<0||Q>this.original.length)throw new Error("Character is out of bounds");if(J>Q)throw new Error("end must be greater than start");this._split(J),this._split(Q);let X=this.byStart[J];while(X)X.reset(),X=Q>X.end?this.byStart[X.end]:null;return this}lastChar(){if(this.outro.length)return this.outro[this.outro.length-1];let J=this.lastChunk;do{if(J.outro.length)return J.outro[J.outro.length-1];if(J.content.length)return J.content[J.content.length-1];if(J.intro.length)return J.intro[J.intro.length-1]}while(J=J.previous);if(this.intro.length)return this.intro[this.intro.length-1];return""}lastLine(){let J=this.outro.lastIndexOf(f);if(J!==-1)return this.outro.substr(J+1);let Q=this.outro,X=this.lastChunk;do{if(X.outro.length>0){if(J=X.outro.lastIndexOf(f),J!==-1)return X.outro.substr(J+1)+Q;Q=X.outro+Q}if(X.content.length>0){if(J=X.content.lastIndexOf(f),J!==-1)return X.content.substr(J+1)+Q;Q=X.content+Q}if(X.intro.length>0){if(J=X.intro.lastIndexOf(f),J!==-1)return X.intro.substr(J+1)+Q;Q=X.intro+Q}}while(X=X.previous);if(J=this.intro.lastIndexOf(f),J!==-1)return this.intro.substr(J+1)+Q;return this.intro+Q}slice(J=0,Q=this.original.length-this.offset){if(J=J+this.offset,Q=Q+this.offset,this.original.length!==0){while(J<0)J+=this.original.length;while(Q<0)Q+=this.original.length}let X="",Z=this.firstChunk;while(Z&&(Z.start>J||Z.end<=J)){if(Z.start<Q&&Z.end>=Q)return X;Z=Z.next}if(Z&&Z.edited&&Z.start!==J)throw new Error(`Cannot use replaced character ${J} as slice start anchor.`);let $=Z;while(Z){if(Z.intro&&($!==Z||Z.start===J))X+=Z.intro;let Y=Z.start<Q&&Z.end>=Q;if(Y&&Z.edited&&Z.end!==Q)throw new Error(`Cannot use replaced character ${Q} as slice end anchor.`);let F=$===Z?J-Z.start:0,z=Y?Z.content.length+Q-Z.end:Z.content.length;if(X+=Z.content.slice(F,z),Z.outro&&(!Y||Z.end===Q))X+=Z.outro;if(Y)break;Z=Z.next}return X}snip(J,Q){let X=this.clone();return X.remove(0,J),X.remove(Q,X.original.length),X}_split(J){if(this.byStart[J]||this.byEnd[J])return;let Q=this.lastSearchedChunk,X=Q,Z=J>Q.end;while(Q){if(Q.contains(J))return this._splitChunk(Q,J);if(Q=Z?this.byStart[Q.end]:this.byEnd[Q.start],Q===X)return;X=Q}}_splitChunk(J,Q){if(J.edited&&J.content.length){let Z=t(this.original)(Q);throw new Error(`Cannot split a chunk that has already been edited (${Z.line}:${Z.column} – "${J.original}")`)}let X=J.split(Q);if(this.byEnd[Q]=J,this.byStart[Q]=X,this.byEnd[X.end]=X,J===this.lastChunk)this.lastChunk=X;return this.lastSearchedChunk=J,!0}toString(){let J=this.intro,Q=this.firstChunk;while(Q)J+=Q.toString(),Q=Q.next;return J+this.outro}isEmpty(){let J=this.firstChunk;do if(J.intro.length&&J.intro.trim()||J.content.length&&J.content.trim()||J.outro.length&&J.outro.trim())return!1;while(J=J.next);return!0}length(){let J=this.firstChunk,Q=0;do Q+=J.intro.length+J.content.length+J.outro.length;while(J=J.next);return Q}trimLines(){return this.trim("[\\r\\n]")}trim(J){return this.trimStart(J).trimEnd(J)}trimEndAborted(J){let Q=new RegExp((J||"\\s")+"+$");if(this.outro=this.outro.replace(Q,""),this.outro.length)return!0;let X=this.lastChunk;do{let Z=X.end,$=X.trimEnd(Q);if(X.end!==Z){if(this.lastChunk===X)this.lastChunk=X.next;this.byEnd[X.end]=X,this.byStart[X.next.start]=X.next,this.byEnd[X.next.end]=X.next}if($)return!0;X=X.previous}while(X);return!1}trimEnd(J){return this.trimEndAborted(J),this}trimStartAborted(J){let Q=new RegExp("^"+(J||"\\s")+"+");if(this.intro=this.intro.replace(Q,""),this.intro.length)return!0;let X=this.firstChunk;do{let Z=X.end,$=X.trimStart(Q);if(X.end!==Z){if(X===this.lastChunk)this.lastChunk=X.next;this.byEnd[X.end]=X,this.byStart[X.next.start]=X.next,this.byEnd[X.next.end]=X.next}if($)return!0;X=X.next}while(X);return!1}trimStart(J){return this.trimStartAborted(J),this}hasChanged(){return this.original!==this.toString()}_replaceRegexp(J,Q){function X($,Y){if(typeof Q==="string")return Q.replace(/\$(\$|&|\d+)/g,(F,z)=>{if(z==="$")return"$";if(z==="&")return $[0];if(+z<$.length)return $[+z];return`$${z}`});else return Q(...$,$.index,Y,$.groups)}function Z($,Y){let F,z=[];while(F=$.exec(Y))z.push(F);return z}if(J.global)Z(J,this.original).forEach((Y)=>{if(Y.index!=null){let F=X(Y,this.original);if(F!==Y[0])this.overwrite(Y.index,Y.index+Y[0].length,F)}});else{let $=this.original.match(J);if($&&$.index!=null){let Y=X($,this.original);if(Y!==$[0])this.overwrite($.index,$.index+$[0].length,Y)}}return this}_replaceString(J,Q){let{original:X}=this,Z=X.indexOf(J);if(Z!==-1){if(typeof Q==="function")Q=Q(J,Z,X);if(J!==Q)this.overwrite(Z,Z+J.length,Q)}return this}replace(J,Q){if(typeof J==="string")return this._replaceString(J,Q);return this._replaceRegexp(J,Q)}_replaceAllString(J,Q){let{original:X}=this,Z=J.length;for(let $=X.indexOf(J);$!==-1;$=X.indexOf(J,$+Z)){let Y=X.slice($,$+Z),F=Q;if(typeof Q==="function")F=Q(Y,$,X);if(Y!==F)this.overwrite($,$+Z,F)}return this}replaceAll(J,Q){if(typeof J==="string")return this._replaceAllString(J,Q);if(!J.global)throw new TypeError("MagicString.prototype.replaceAll called with a non-global RegExp argument");return this._replaceRegexp(J,Q)}}function u(J=""){let Q=J.length,X=Q^Q,Z=0,$;while(Q>=4)$=J.charCodeAt(Z)&255|(J.charCodeAt(++Z)&255)<<8|(J.charCodeAt(++Z)&255)<<16|(J.charCodeAt(++Z)&255)<<24,$=($&65535)*1540483477+((($>>>16)*1540483477&65535)<<16),$^=$>>>24,$=($&65535)*1540483477+((($>>>16)*1540483477&65535)<<16),X=(X&65535)*1540483477+(((X>>>16)*1540483477&65535)<<16)^$,Q-=4,++Z;if(Q>=3)X^=(J.charCodeAt(Z+2)&255)<<16;if(Q>=2)X^=(J.charCodeAt(Z+1)&255)<<8;if(Q>=1)X^=J.charCodeAt(Z)&255,X=(X&65535)*1540483477+(((X>>>16)*1540483477&65535)<<16);return X^=X>>>13,X=(X&65535)*1540483477+(((X>>>16)*1540483477&65535)<<16),X^=X>>>15,(X>>>0).toString(36)}function d(J){return/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(J)}function T(J){return JSON.stringify(J)}function JJ(J){return(J.split("/").pop()||"unknown").replace(/\.[^.]+$/,"").replace(/[^a-zA-Z0-9]/g,"")}function jJ(J={}){let{classPrefix:Q="ss",debug:X}=J,Z=X??process.env.DEBUG_STYLED_STATIC==="true",$=new Map,Y,F=!1;return{name:"styled-static",enforce:"post",configResolved(z){Y=z,F=Y.command==="serve"},resolveId(z){if(z.startsWith("virtual:styled-static/"))return"\x00"+z;if(z.startsWith("\x00virtual:styled-static/"))return z;return null},load(z){if(z.startsWith("\x00virtual:styled-static/")){let q=z.slice(1).replace(/\.(css|js)$/,".css"),A=$.get(q),H=A?.css??"";if(F){let G=A?.sourceFile??"",K=G?`${H}
/*# sourceURL=${G} */`:H;return`
const id = ${JSON.stringify(q)};
const css = ${JSON.stringify(K)};

// Remove existing style for this module (HMR cleanup)
const existing = document.querySelector(\`style[data-ss-id="\${id}"]\`);
if (existing) existing.remove();

const style = document.createElement('style');
style.setAttribute('data-ss-id', id);
style.textContent = css;
document.head.appendChild(style);

if (import.meta.hot) {
  import.meta.hot.accept();
}

export default css;
`}return H}return null},handleHotUpdate({file:z,server:W}){if(/\.[tj]sx?$/.test(z)){let q=l(z);for(let[A]of $)if(A.includes(q)){let H=W.moduleGraph.getModuleById(`\x00${A}`);if(H)W.moduleGraph.invalidateModule(H)}}},async transform(z,W){if(!/\.[cm]?[jt]sx?$/.test(W)||/node_modules/.test(W))return null;let q=z.includes("styled-static"),A=z.includes('from "./index"')||z.includes("from './index'")||z.includes('from "../index"')||z.includes("from '../index'");if(!q&&!A)return null;if(Z)console.log("[styled-static] Transforming:",W);let H;try{if(H=this.parse(z),Z)console.log("[styled-static] AST parsed successfully, body length:",H.body.length)}catch(U){if(Z)console.log("[styled-static] AST parse error:",U);return null}let G=_J(H);if(Z)console.log("[styled-static] Found imports:",G);let K=G.css||G.styled||G.createGlobalStyle||G.keyframes,O=G.styledVariants||G.cssVariants,D=!!G.withComponent;if(!K&&!O&&!D){if(Z)console.log("[styled-static] No imports found, skipping");return null}let j=K?OJ(H,G,z):[];if(Z)console.log("[styled-static] Found templates:",j.length);let R=O?RJ(H,z,G):[];if(Z)console.log("[styled-static] Found variant calls:",R.length);let P=D?NJ(H,G):[];if(Z)console.log("[styled-static] Found withComponent calls:",P.length);if(j.length===0&&R.length===0&&P.length===0){if(Z)console.log("[styled-static] No templates, variants, or withComponent found, skipping");return null}let E=new m(z),I=[],v=!1,c=0;for(let U=0;U<j.length;U++){let _=j[U];if(!_)continue;let B=EJ(z,_.node.quasi),M;if(F&&_.variableName){let b=JJ(W);M=`${Q}-${_.variableName}-${b}`}else{let b=F?6:8,p=u(B).slice(0,b);M=`${Q}-${p}`}let C=_.type==="createGlobalStyle"?B:`.${M} { ${B} }`,x=`virtual:styled-static/${l(W)}/${c++}`,k=`${x}.css`,L=F?`${x}.js`:k;$.set(k,{css:C,sourceFile:W}),I.push(`import "${L}";`);let V=BJ(_,M,F);if(E.overwrite(_.node.start,_.node.end,V),_.type==="styled"||_.type==="styledExtend"||_.type==="styledAttrs")v=!0}let h=[];for(let U of R){let _;if(F&&U.variableName){let V=JJ(W);_=`${Q}-${U.variableName}-${V}`}else{let V=u(U.baseCss||"").slice(0,6);_=`${Q}-${V}`}let B="";if(U.baseCss)B+=`.${_} { ${U.baseCss} }
`;for(let[V,b]of U.variants)for(let[p,XJ]of b){let ZJ=`${_}--${V}-${p}`;B+=`.${ZJ} { ${XJ} }
`}let M=`virtual:styled-static/${l(W)}/${c++}`,C=`${M}.css`,x=F?`${M}.js`:C;$.set(C,{css:B,sourceFile:W}),I.push(`import "${x}";`);let k=Array.from(U.variants.keys()),L=VJ(U,_,k,F);if(E.overwrite(U.start,U.end,L.code),L.hoisted)h.push(L.hoisted);if(U.type==="styledVariants")v=!0}for(let U of P){if(!d(U.fromComponent))throw new Error(`[styled-static] Invalid fromComponent name: ${U.fromComponent}`);let _=/^[a-z]/.test(U.toComponent),B;if(_)B=`Object.assign((p) => createElement(${T(U.toComponent)}, {...p, className: m(${U.fromComponent}.className, p.className)}), { className: ${U.fromComponent}.className })`;else{if(!d(U.toComponent))throw new Error(`[styled-static] Invalid toComponent name: ${U.toComponent}`);B=`Object.assign((p) => createElement(${U.toComponent}, {...p, className: m(${U.fromComponent}.className, p.className)}), { className: ${U.fromComponent}.className })`}E.overwrite(U.start,U.end,B),v=!0}let QJ=G.source==="./index"||G.source==="../index"?G.source.replace("/index","/runtime"):"styled-static/runtime",N="";if(I.length>0)N+=I.join(`
`)+`
`;if(v)N+=`import { createElement } from "react";
`,N+=`import { m } from "${QJ}";
`;if(h.length>0)N+=h.join(`
`)+`
`;if(N)E.prepend(N+`
`);return{code:E.toString(),map:E.generateMap({hires:!0})}}}}function _J(J){let Q={};for(let X of J.body)if(X.type==="ImportDeclaration"){let Z=X.source.value;if(Z==="styled-static"||Z==="./index"||Z==="../index"){Q.source=Z;for(let Y of X.specifiers)if(Y.type==="ImportSpecifier"){let F=Y.imported.name,z=Y.local.name;if(F==="styled")Q.styled=z;if(F==="css")Q.css=z;if(F==="createGlobalStyle")Q.createGlobalStyle=z;if(F==="keyframes")Q.keyframes=z;if(F==="styledVariants")Q.styledVariants=z;if(F==="cssVariants")Q.cssVariants=z;if(F==="withComponent")Q.withComponent=z}}}return Q}function OJ(J,Q,X){let Z=[];function $(Y){for(let F of Y.declarations)if(F.init?.type==="TaggedTemplateExpression"&&F.id.type==="Identifier"){let z=F.init,W=F.id.name,q=DJ(z,Q,W,X);if(q)Z.push(q)}}for(let Y of J.body){if(Y.type==="VariableDeclaration")$(Y);if(Y.type==="ExportNamedDeclaration"&&Y.declaration?.type==="VariableDeclaration")$(Y.declaration)}return Z}function DJ(J,Q,X,Z){let{tag:$}=J;if($.type==="MemberExpression"&&$.object.type==="Identifier"&&$.object.name===Q.styled&&$.property.type==="Identifier")return{type:"styled",node:J,tag:$.property.name,variableName:X};if($.type==="CallExpression"&&$.callee.type==="Identifier"&&$.callee.name===Q.styled&&$.arguments[0]?.type==="Identifier")return{type:"styledExtend",node:J,tag:"",baseComponent:$.arguments[0].name,variableName:X};if($.type==="Identifier"&&$.name===Q.css)return{type:"css",node:J,tag:"",variableName:X};if($.type==="Identifier"&&$.name===Q.createGlobalStyle)return{type:"createGlobalStyle",node:J,tag:"",variableName:X};if($.type==="Identifier"&&$.name===Q.keyframes)return{type:"keyframes",node:J,tag:"",variableName:X};if($.type==="CallExpression"&&$.callee.type==="MemberExpression"&&$.callee.property.type==="Identifier"&&$.callee.property.name==="attrs"&&$.callee.object.type==="MemberExpression"&&$.callee.object.object.type==="Identifier"&&$.callee.object.object.name===Q.styled&&$.callee.object.property.type==="Identifier"&&$.arguments.length===1){let Y=$.callee.object.property.name,F=$.arguments[0],z=Z.slice(F.start,F.end);return{type:"styledAttrs",node:J,tag:Y,variableName:X,attrsArg:z}}return null}function EJ(J,Q){return J.slice(Q.start+1,Q.end-1)}function BJ(J,Q,X){let Z=T(Q);switch(J.type){case"styled":return`Object.assign((p) => createElement(${T(J.tag)}, {...p, className: m(${Z}, p.className)}), { className: ${Z} })`;case"styledExtend":return`Object.assign((p) => createElement(${J.baseComponent}, {...p, className: m(${Z}, p.className)}), { className: ${J.baseComponent}.className + " " + ${Z} })`;case"styledAttrs":return`Object.assign((p) => createElement(${T(J.tag)}, {...(${J.attrsArg??"{}"}), ...p, className: m(${Z}, p.className)}), { className: ${Z} })`;case"css":return Z;case"keyframes":return Z;case"createGlobalStyle":return"() => null"}}function l(J){return J.replace(/\\/g,"/").replace(/^\/+/,"").toLowerCase()}function RJ(J,Q,X){let Z=[];function $(Y){for(let F of Y.declarations)if(F.init?.type==="CallExpression"&&F.id.type==="Identifier"){let z=F.init,W=F.id.name,q=TJ(z,Q,X,W);if(q)Z.push(q)}}for(let Y of J.body){if(Y.type==="VariableDeclaration")$(Y);if(Y.type==="ExportNamedDeclaration"&&Y.declaration?.type==="VariableDeclaration")$(Y.declaration)}return Z}function TJ(J,Q,X,Z){if(J.callee.type!=="Identifier")return null;let $=J.callee.name,Y=$===X.styledVariants,F=$===X.cssVariants;if(!Y&&!F)return null;if(J.arguments.length!==1||J.arguments[0]?.type!=="ObjectExpression")return null;let z=J.arguments[0],W,q,A=new Map;for(let H of z.properties){if(H.type!=="Property"||H.key.type!=="Identifier")continue;let G=H.key.name;if(G==="component"){if(H.value.type==="Literal"&&typeof H.value.value==="string")W=H.value.value;else if(H.value.type==="Identifier")W=H.value.name}if(G==="css"){if(H.value.type==="Literal"&&typeof H.value.value==="string")q=H.value.value;else if(H.value.type==="TemplateLiteral"){let K=H.value;q=Q.slice(K.start+1,K.end-1)}else if(H.value.type==="TaggedTemplateExpression"){let K=H.value;if(K.tag.type==="Identifier"&&K.tag.name===X.css)q=Q.slice(K.quasi.start+1,K.quasi.end-1)}}if(G==="variants"&&H.value.type==="ObjectExpression")for(let K of H.value.properties){if(K.type!=="Property"||K.key.type!=="Identifier")continue;if(K.value.type!=="ObjectExpression")continue;let O=K.key.name,D=new Map;for(let j of K.value.properties){if(j.type!=="Property"||j.key.type!=="Identifier")continue;let R=j.key.name,P;if(j.value.type==="Literal"&&typeof j.value.value==="string")P=j.value.value;else if(j.value.type==="TemplateLiteral"){let E=j.value;P=Q.slice(E.start+1,E.end-1)}else if(j.value.type==="TaggedTemplateExpression"){let E=j.value;if(E.tag.type==="Identifier"&&E.tag.name===X.css)P=Q.slice(E.quasi.start+1,E.quasi.end-1)}if(P)D.set(R,P)}if(D.size>0)A.set(O,D)}}return{type:Y?"styledVariants":"cssVariants",start:J.start,end:J.end,component:W,baseCss:q,variants:A,variableName:Z}}var PJ=4,MJ=0;function VJ(J,Q,X,Z){let $=T(Q),Y=J.type==="cssVariants",z=X.reduce((H,G)=>H+(J.variants.get(G)?.size??0),0)>PJ,W=X.length>0?`{ ${X.join(", ")}, className, ...p }`:"{ className, ...p }",q,A;if(z&&X.length>0){let H=`_vm${MJ++}`,G=X.map((O)=>{let D=J.variants.get(O);if(!D)return"";let j=Array.from(D.keys()).map((R)=>`${T(R)}:${T(` ${Q}--${O}-${R}`)}`).join(",");return`${O}:{${j}}`});A=`const ${H}={${G.join(",")}};`,q=X.map((O)=>{let D=Y?`variants.${O}`:O;return`c+=${H}.${O}[${D}]||""`}).join(";")+";"}else{let H=[];for(let G of X){let K=J.variants.get(G);if(K){let O=Y?`variants.${G}`:G,D=Array.from(K.keys()).map((j,R)=>`${R===0?"if":"else if"} (${O} === ${T(j)}) c += ${T(` ${Q}--${G}-${j}`)}`).join("; ");if(D)H.push(D)}}q=H.length>0?H.join("; ")+"; ":""}if(J.type==="styledVariants")if(J.component&&/^[a-z]/.test(J.component)){if(!J.component||!/^[a-z][a-z0-9]*$/.test(J.component))throw new Error(`[styled-static] Invalid HTML tag name: ${J.component}`);let G=T(J.component);return{code:`Object.assign((${W}) => { let c = ${$}; ${q}return createElement(${G}, {...p, className: m(c, className)}); }, { className: ${$} })`,hoisted:A}}else{if(!J.component||!d(J.component))throw new Error(`[styled-static] Invalid component name: ${J.component}`);return{code:`Object.assign((${W}) => { let c = ${$}; ${q}return createElement(${J.component}, {...p, className: m(c, className)}); }, { className: ${J.component}.className + " " + ${$} })`,hoisted:A}}return{code:`(variants) => { let c = ${$}; ${q}return c; }`,hoisted:A}}function NJ(J,Q){let X=[];function Z($){for(let Y of $.declarations)if(Y.init?.type==="CallExpression"&&Y.id.type==="Identifier"){let F=Y.init,z=Y.id.name;if(F.callee.type==="Identifier"&&F.callee.name===Q.withComponent&&F.arguments.length===2){let W=F.arguments[0],q=F.arguments[1],A,H;if(W?.type==="Literal"&&typeof W.value==="string")A=W.value;else if(W?.type==="Identifier")A=W.name;if(q?.type==="Identifier")H=q.name;if(A&&H)X.push({start:F.start,end:F.end,toComponent:A,fromComponent:H,variableName:z})}}}for(let $ of J.body){if($.type==="VariableDeclaration")Z($);if($.type==="ExportNamedDeclaration"&&$.declaration?.type==="VariableDeclaration")Z($.declaration)}return X}var CJ=jJ;export{jJ as styledStatic,CJ as default};
